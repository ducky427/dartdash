{"dependencies":[{"uri":"sdk/lib/core/core.dart","name":"dart:core","id":"dart.core","children":[{"comment":"\nEverything in Dart is an [Object].\n","uri":"sdk/lib/core/object.dart","name":"Object","id":"Object","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"isOperator":true,"comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","name":"==","id":"==1()","children":[{"name":"other","id":"other","kind":"param"}],"line":"29","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"comment":"\nReturns a string representation of this object.\n","name":"toString","id":"toString0()","line":"48","kind":"method"},{"comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [Invocation].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","name":"noSuchMethod","id":"noSuchMethod1()","children":[{"ref":{"refId":"dart.core/Invocation","name":"Invocation"},"name":"invocation","id":"invocation","kind":"param"}],"line":"60","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","name":"hashCode","id":"hashCode","line":"43","kind":"property"},{"ref":{"refId":"dart.core/Type","name":"Type"},"comment":"\nA representation of the runtime type of the object.\n","name":"runtimeType","id":"runtimeType","line":"65","kind":"property"},{"comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","name":"Object","id":"Object0()","line":"18","kind":"constructor"}],"line":"10","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [Map] is an associative container, mapping a key to a value.\nNull values are supported, but null keys are not.\n","uri":"sdk/lib/core/map.dart","name":"Map","id":"Map","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns whether this map contains the given [value].\n","name":"containsValue","id":"containsValue1()","children":[{"ref":{"refId":"dart.core/Map/V","name":"V"},"name":"value","id":"value","kind":"param"}],"line":"25","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns whether this map contains the given [key].\n","name":"containsKey","id":"containsKey1()","children":[{"ref":{"refId":"dart.core/Map/K","name":"K"},"name":"key","id":"key","kind":"param"}],"line":"30","kind":"method"},{"returnType":{"refId":"dart.core/Map/V","name":"V"},"isOperator":true,"comment":"\nReturns the value for the given [key] or null if [key] is not\nin the map. Because null values are supported, one should either\nuse containsKey to distinguish between an absent key and a null\nvalue, or use the [putIfAbsent] method.\n","name":"[]","id":"[]1()","children":[{"ref":{"refId":"dart.core/Map/K","name":"K"},"name":"key","id":"key","kind":"param"}],"line":"38","kind":"method"},{"returnType":{"refId":"void","name":"void"},"isOperator":true,"comment":"\nAssociates the [key] with the given [value].\n","name":"[]=","id":"[]=2()","children":[{"ref":{"refId":"dart.core/Map/K","name":"K"},"name":"key","id":"key","kind":"param"},{"ref":{"refId":"dart.core/Map/V","name":"V"},"name":"value","id":"value","kind":"param"}],"line":"43","kind":"method"},{"returnType":{"refId":"dart.core/Map/V","name":"V"},"comment":"\nIf [key] is not associated to a value, calls [ifAbsent] and\nupdates the map by mapping [key] to the value returned by\n[ifAbsent]. Returns the value in the map.\n\nIt is an error to add or remove keys from map during the call to\n[ifAbsent].\n","name":"putIfAbsent","id":"putIfAbsent2()","children":[{"ref":{"refId":"dart.core/Map/K","name":"K"},"name":"key","id":"key","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"ifAbsent","id":"ifAbsent","children":[{"returnType":{"refId":"dart.core/Map/V","name":"V"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","line":"13","kind":"functiontype"}],"kind":"param"}],"line":"53","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nAdds all key-value pairs of [other] to this map.\n\nIf a key of [other] is already in this map, its value is overwritten.\n\nThe operation is equivalent to doing `this[key] = value` for each key\nand associated value in other. It iterates over [other], which must\ntherefore not change during the iteration.\n","name":"addAll","id":"addAll1()","children":[{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Map/K","name":"K"},{"refId":"dart.core/Map/V","name":"V"}],"name":"Map"},"name":"other","id":"other","kind":"param"}],"line":"64","kind":"method"},{"returnType":{"refId":"dart.core/Map/V","name":"V"},"comment":"\nRemoves the association for the given [key]. Returns the value for\n[key] in the map or null if [key] is not in the map. Note that values\ncan be null and a returned null value does not always imply that the\nkey is absent.\n","name":"remove","id":"remove1()","children":[{"ref":{"refId":"dart.core/Map/K","name":"K"},"name":"key","id":"key","kind":"param"}],"line":"72","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nRemoves all pairs from the map.\n","name":"clear","id":"clear0()","line":"77","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nApplies [f] to each {key, value} pair of the map.\n\nIt is an error to add or remove keys from the map during iteration.\n","name":"forEach","id":"forEach1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"void","name":"void"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Map/K","name":"K"},"uri":"sdk/lib/core/map.dart","name":"key","id":"key","line":"84","kind":"param"},{"ref":{"refId":"dart.core/Map/V","name":"V"},"uri":"sdk/lib/core/map.dart","name":"value","id":"value","line":"84","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"84","kind":"method"},{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Map/K","name":"K"}],"name":"Iterable"},"comment":"\nThe keys of [this].\n","name":"keys","id":"keys","line":"90","kind":"property"},{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Map/V","name":"V"}],"name":"Iterable"},"comment":"\nThe values of [this].\n","name":"values","id":"values","line":"95","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nThe number of {key, value} pairs in the map.\n","name":"length","id":"length","line":"100","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns true if there is no {key, value} pair in the map.\n","name":"isEmpty","id":"isEmpty","line":"105","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns true if there is at least one {key, value} pair in the map.\n","name":"isNotEmpty","id":"isNotEmpty","line":"110","kind":"property"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Map/K","name":"K"},{"refId":"dart.core/Map/V","name":"V"}],"name":"Map"},"comment":"\nCreates a map with the default implementation.\n","name":"Map","id":"Map0()","line":"15","kind":"constructor"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Map/K","name":"K"},{"refId":"dart.core/Map/V","name":"V"}],"name":"Map"},"comment":"\nCreates a [Map] that contains all key value pairs of [other].\n","name":"Map.from","id":"Map.from1()","children":[{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Map/K","name":"K"},{"refId":"dart.core/Map/V","name":"V"}],"name":"Map"},"name":"other","id":"other","kind":"param"}],"line":"20","kind":"constructor"},{"name":"K","id":"K","kind":"typeparam"},{"name":"V","id":"V","kind":"typeparam"}],"line":"11","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [List] is an indexable collection with a length.\n\nA `List` implementation can choose not to support all methods\nof the `List` interface.\n\nThe most common list types are:\n* Fixed length list. It is an error to use operations that can change\n  the list's length.\n* Growable list. Full implementation of the interface.\n* Unmodifiable list. It is an error to use operations that can change\n  the list's length, or that can change the values of the list.\n  If an unmodifable list is backed by another modifiable data structure,\n  the values read from it may still change over time.\n\nExample:\n\n    var fixedLengthList = new List(5);\n    fixedLengthList.length = 0;  // throws.\n    fixedLengthList.add(499);  // throws\n    fixedLengthList[0] = 87;\n    var growableList = [1, 2];\n    growableList.length = 0;\n    growableList.add(499);\n    growableList[0] = 87;\n    var unmodifiableList = const [1, 2];\n    unmodifiableList.length = 0;  // throws.\n    unmodifiableList.add(499);  // throws\n    unmodifiableList[0] = 87;  // throws.\n\nLists are [Iterable].\nList iteration iterates over values in index order.\nChanging the values will not affect iteration,\nbut changing the valid indices -\nthat is, changing the list's length -\nbetween iteration steps\nwill cause a [ConcurrentModificationError].\nThis means that only growable lists can throw [ConcurrentModificationError].\nIf the length changes temporarily\nand is restored before continuing the iteration,\nthe iterator will not detect it.\n","uri":"sdk/lib/core/list.dart","name":"List","id":"List","children":[{"returnType":{"refId":"dart.core/List/E","name":"E"},"isOperator":true,"comment":"\nReturns the element at the given [index] in the list or throws\nan [RangeError] if [index] is out of bounds.\n","name":"[]","id":"[]1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"}],"line":"117","kind":"method"},{"returnType":{"refId":"void","name":"void"},"isOperator":true,"comment":"\nSets the entry at the given [index] in the list to [value].\n\nThrows an [RangeError] if [index] is out of bounds.\n","name":"[]=","id":"[]=2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"},{"ref":{"refId":"dart.core/List/E","name":"E"},"name":"value","id":"value","kind":"param"}],"line":"124","kind":"method"},{"returnType":{"refId":"void","name":"void"},"isSetter":true,"comment":"\nChanges the length of the list. If [newLength] is greater than\nthe current [length], entries are initialized to [:null:].\n\nThrows an [UnsupportedError] if the list is not extendable.\n","name":"length=","id":"length=1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"newLength","id":"newLength","kind":"param"}],"line":"139","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nAdds [value] at the end of the list, extending the length by\none.\n\nThrows an [UnsupportedError] if the list is not extendable.\n","name":"add","id":"add1()","children":[{"ref":{"refId":"dart.core/List/E","name":"E"},"name":"value","id":"value","kind":"param"}],"line":"147","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nAppends all elements of the [iterable] to the end of this list.\n\nExtends the length of the list by the number of elements in [iterable].\nThrows an [UnsupportedError] if this list is not extensible.\n","name":"addAll","id":"addAll1()","children":[{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"},"name":"iterable","id":"iterable","kind":"param"}],"line":"155","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nSorts the list according to the order specified by the [compare] function.\n\nThe [compare] function must act as a [Comparator].\n\nThe default [List] implementations use [Comparable.compare] if\n[compare] is omitted.\n","name":"sort","id":"sort1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"name":"compare","id":"compare","children":[{"returnType":{"refId":"dart.core/int","name":"int"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/List/E","name":"E"},"uri":"sdk/lib/core/list.dart","name":"a","id":"a","line":"170","kind":"param"},{"ref":{"refId":"dart.core/List/E","name":"E"},"uri":"sdk/lib/core/list.dart","name":"b","id":"b","line":"170","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"170","kind":"method"},{"returnType":{"refId":"dart.core/int","name":"int"},"comment":"\nReturns the first index of [element] in the list.\n\nSearches the list from index [start] to the length of the list.\nThe first time an element [:e:] is encountered so that [:e == element:],\nthe index of [:e:] is returned.\nReturns -1 if [element] is not found.\n","name":"indexOf","id":"indexOf2()","children":[{"ref":{"refId":"dart.core/List/E","name":"E"},"name":"element","id":"element","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"isOptional":true,"defaultValue":"0","name":"start","id":"start","kind":"param"}],"line":"180","kind":"method"},{"returnType":{"refId":"dart.core/int","name":"int"},"comment":"\nReturns the last index of [element] in the list.\n\nSearches the list backwards from index [start] (inclusive) to 0.\n\nThe first time an element [:e:] is encountered so that [:e == element:],\nthe index of [:e:] is returned.\n\nIf start is not provided, it defaults to [:this.length - 1:].\n\nReturns -1 if [element] is not found.\n","name":"lastIndexOf","id":"lastIndexOf2()","children":[{"ref":{"refId":"dart.core/List/E","name":"E"},"name":"element","id":"element","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"isOptional":true,"name":"start","id":"start","kind":"param"}],"line":"194","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nRemoves all elements in the list.\n\nThe length of the list becomes zero.\n\nThrows an [UnsupportedError], and retains all elements, if the\nlength of the list cannot be changed.\n","name":"clear","id":"clear0()","line":"204","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nInserts the element at position [index] in the list.\n\nThis increases the length of the list by one and shifts all elements\nat or after the index towards the end of the list.\n\nIt is an error if the [index] does not point inside the list or at the\nposition after the last element.\n","name":"insert","id":"insert2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"},{"ref":{"refId":"dart.core/List/E","name":"E"},"name":"element","id":"element","kind":"param"}],"line":"215","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nInserts all elements of [iterable] at position [index] in the list.\n\nThis increases the length of the list by the length of [iterable] and\nshifts all later elements towards the end of the list.\n\nIt is an error if the [index] does not point inside the list or at the\nposition after the last element.\n","name":"insertAll","id":"insertAll2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"},{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"},"name":"iterable","id":"iterable","kind":"param"}],"line":"226","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nOverwrites elements of `this` with the elemenst of [iterable] starting\nat position [index] in the list.\n\nThis operation does not increase the length of `this`.\n\nIt is an error if the [index] does not point inside the list or at the\nposition after the last element.\n\nIt is an error if the [iterable] is longer than [length] - [index].\n","name":"setAll","id":"setAll2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"},{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"},"name":"iterable","id":"iterable","kind":"param"}],"line":"239","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nRemoves [value] from the list. Returns true if [value] was\nin the list. Returns false otherwise. The method has no effect\nif [value] value was not in the list.\n","name":"remove","id":"remove1()","children":[{"ref":{"refId":"dart.core/Object","name":"Object"},"name":"value","id":"value","kind":"param"}],"line":"246","kind":"method"},{"returnType":{"refId":"dart.core/List/E","name":"E"},"comment":"\nRemoves the element at position [index] from the list.\n\nThis reduces the length of `this` by one and moves all later elements\ndown by one position.\n\nReturns the removed element.\n\nThrows an [ArgumentError] if [index] is not an [int].\n\nThrows an [RangeError] if the [index] does not point inside\nthe list.\n\nThrows an [UnsupportedError], and doesn't remove the element,\nif the length of `this` cannot be changed.\n","name":"removeAt","id":"removeAt1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"}],"line":"264","kind":"method"},{"returnType":{"refId":"dart.core/List/E","name":"E"},"comment":"\nPops and returns the last element of the list.\nThrows a [UnsupportedError] if the length of the\nlist cannot be changed.\n","name":"removeLast","id":"removeLast0()","line":"271","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nRemoves all elements of this list that satisfy [test].\n\nAn elements [:e:] satisfies [test] if [:test(e):] is true.\n","name":"removeWhere","id":"removeWhere1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/List/E","name":"E"},"uri":"sdk/lib/core/list.dart","name":"element","id":"element","line":"278","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"278","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nRemoves all elements of this list that fail to satisfy [test].\n\nAn elements [:e:] satisfies [test] if [:test(e):] is true.\n","name":"retainWhere","id":"retainWhere1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/List/E","name":"E"},"uri":"sdk/lib/core/list.dart","name":"element","id":"element","line":"285","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"285","kind":"method"},{"returnType":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"List"},"comment":"\nReturns a new list containing the elements from [start] to [end].\n\nIf [end] is omitted, the [length] of `this` is used.\n\nIt is an error if [start] or [end] are not indices into `this`,\nor if [end] is before [start].\n","name":"sublist","id":"sublist2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"start","id":"start","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"isOptional":true,"name":"end","id":"end","kind":"param"}],"line":"295","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"},"comment":"\nReturns an [Iterable] that iterators over the elements in the range\n[start] to [end] exclusive. The result of this function\nis backed by `this`.\n\nIt is an error if [end] is before [start].\n\nIt is an error if the [start] and [end] are not valid ranges at the time\nof the call to this method. The returned [Iterable] behaves similar to\n`skip(start).take(end - start)`. That is, it will not throw exceptions\nif `this` changes size.\n\nExample:\n\n    var list = [1, 2, 3, 4, 5];\n    var range = list.getRange(1, 4);\n    print(range.join(', '));  // => 2, 3, 4\n    list.length = 3;\n    print(range.join(', '));  // => 2, 3\n","name":"getRange","id":"getRange2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"start","id":"start","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"end","id":"end","kind":"param"}],"line":"317","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nCopies the elements of [iterable], skipping the [skipCount] first elements,\ninto the range [start] to [end] exclusive of `this`.\n\nIf [start] equals [end] and [start]..[end] represents a legal range, this\nmethod has no effect.\n\nIt is an error if [start]..[end] is not a valid range pointing into the\n`this`.\n\nIt is an error if the [iterable] does not have enough elements after\nskipping [skipCount] elements.\n\nExample:\n\n    var list = [1, 2, 3, 4];\n    var list2 = [5, 6, 7, 8, 9];\n    list.setRange(1, 3, list2, 3);\n    print(list);  // => [1, 8, 9, 4]\n","name":"setRange","id":"setRange4()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"start","id":"start","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"end","id":"end","kind":"param"},{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"},"name":"iterable","id":"iterable","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"isOptional":true,"defaultValue":"0","name":"skipCount","id":"skipCount","kind":"param"}],"line":"339","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nRemoves the elements in the range [start] to [end] exclusive.\n\nIt is an error if [start]..[end] is not a valid range pointing into the\n`this`.\n","name":"removeRange","id":"removeRange2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"start","id":"start","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"end","id":"end","kind":"param"}],"line":"347","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nSets the elements in the range [start] to [end] exclusive to the given\n[fillValue].\n\nIt is an error if [start]..[end] is not a valid range pointing into the\n`this`.\n","name":"fillRange","id":"fillRange3()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"start","id":"start","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"end","id":"end","kind":"param"},{"ref":{"refId":"dart.core/List/E","name":"E"},"isOptional":true,"name":"fillValue","id":"fillValue","kind":"param"}],"line":"356","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nRemoves the elements in the range [start] to [end] exclusive and replaces\nthem with the contents of the [iterable].\n\nIt is an error if [start]..[end] is not a valid range pointing into the\n`this`.\n\nExample:\n\n    var list = [1, 2, 3, 4, 5];\n    list.replaceRange(1, 3, [6, 7, 8, 9]);\n    print(list);  // [1, 6, 7, 8, 9, 4, 5]\n","name":"replaceRange","id":"replaceRange3()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"start","id":"start","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"end","id":"end","kind":"param"},{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"},"name":"iterable","id":"iterable","kind":"param"}],"line":"371","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/int","name":"int"},{"refId":"dart.core/List/E","name":"E"}],"name":"Map"},"comment":"\nReturns an unmodifiable [Map] view of `this`.\n\nIt has the indices of this list as keys, and the corresponding elements\nas values. The [Map.keys] [Iterable] will iterate the indices of this list\nin numerical order.\n","name":"asMap","id":"asMap0()","line":"380","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nReturns the number of elements in the list.\n\nThe valid indices for a list are 0 through `length - 1`.\n","name":"length","id":"length","line":"131","kind":"property"},{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"Iterable"},"comment":"\nReturns an [Iterable] of the elements of this [List] in reverse order.\n","name":"reversed","id":"reversed","line":"160","kind":"property"},{"returnType":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"List"},"comment":"\nCreates a list of the given [length].\n\nThe list is a fixed-length list if [length] is provided, and an empty\ngrowable list if [length] is omitted.\n\nIt is an error if [length] is not a non-negative integer.\n","name":"List","id":"List1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"isOptional":true,"name":"length","id":"length","kind":"param"}],"line":"58","kind":"constructor"},{"returnType":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"List"},"comment":"\nCreates a fixed-length list of the given [length] where each entry\ncontains [fill].\n","name":"List.filled","id":"List.filled2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","kind":"param"},{"ref":{"refId":"dart.core/List/E","name":"E"},"name":"fill","id":"fill","kind":"param"}],"line":"64","kind":"constructor"},{"returnType":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"List"},"comment":"\nCreates an list with the elements of [other].\n\nThe order in the list will be\nthe order provided by the iterator of [other].\n\nThe returned list is growable if [growable] is true, otherwise it's\na fixed length list.\n","name":"List.from","id":"List.from2()","children":[{"ref":{"refId":"dart.core/Iterable","name":"Iterable"},"name":"other","id":"other","kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/bool","name":"bool"},"isOptional":true,"defaultValue":"true","name":"growable","id":"growable","kind":"param"}],"line":"75","kind":"constructor"},{"returnType":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List/E","name":"E"}],"name":"List"},"comment":"\nGenerate a `List` of values.\n\nCreates a list with [length] positions\nand fills them by values created by calling [generator]\nfor each index in the range `0` .. `[length] - 1`\nin increasing order.\n\nThe created list's length is fixed unless [growable] is true.\n","name":"List.generate","id":"List.generate3()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"generator","id":"generator","children":[{"returnType":{"refId":"dart.core/List/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/int","name":"int"},"uri":"sdk/lib/core/list.dart","name":"index","id":"index","line":"99","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/bool","name":"bool"},"isOptional":true,"defaultValue":"true","name":"growable","id":"growable","line":"100","kind":"param"}],"line":"99","kind":"constructor"},{"name":"E","id":"E","kind":"typeparam"}],"line":"49","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThe [Iterable] interface allows to get an [Iterator] out of an\n[Iterable] object.\n\nThis interface is used by the for-in construct to iterate over an\n[Iterable] object.\nThe for-in construct takes an [Iterable] object at the right-hand\nside, and calls its [iterator] method to get an [Iterator] on it.\n\nA user-defined class that implements the [Iterable] interface can\nbe used as the right-hand side of a for-in construct.\n","uri":"sdk/lib/core/iterable.dart","name":"Iterable","id":"Iterable","children":[{"returnType":{"refId":"dart.core/Iterable","name":"Iterable"},"comment":"\nReturns a lazy [Iterable] where each element [:e:] of `this` is replaced\nby the result of [:f(e):].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [f] will\nnot be invoked. The transformed elements will not be cached. Iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [f] multiple times on the same element.\n","name":"map","id":"map1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"51","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"51","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Iterable"},"comment":"\nReturns a lazy [Iterable] with all elements that satisfy the\npredicate [test].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [test] will\nnot be invoked. Iterating will not cache results, and thus iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [test] multiple times on the same element.\n","name":"where","id":"where1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"63","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"63","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","name":"Iterable"},"comment":"\nExpand each element of this [Iterable] into zero or more elements.\n\nThe resulting Iterable will run through the elements returned\nby [f] for each element of this, in order.\n\nThe returned [Iterable] is lazy, and will call [f] for each element\nof this every time it's iterated.\n","name":"expand","id":"expand1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"dart.core/Iterable","name":"Iterable"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"74","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"74","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nCheck whether the collection contains an element equal to [element].\n","name":"contains","id":"contains1()","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"name":"element","id":"element","kind":"param"}],"line":"79","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nApplies the function [f] to each element of this collection.\n","name":"forEach","id":"forEach1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"void","name":"void"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"84","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"84","kind":"method"},{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReduces a collection to a single value by iteratively combining elements\nof the collection using the provided function.\n\nExample of calculating the sum of an iterable:\n\n    iterable.reduce((value, element) => value + element);\n\n","name":"reduce","id":"reduce1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"combine","id":"combine","children":[{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"value","id":"value","line":"95","kind":"param"},{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"95","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"95","kind":"method"},{"comment":"\nReduces a collection to a single value by iteratively combining each\nelement of the collection with an existing value using the provided\nfunction.\n\nUse [initialValue] as the initial value, and the function [combine] to\ncreate a new value from the previous one and an element.\n\nExample of calculating the sum of an iterable:\n\n    iterable.fold(0, (prev, element) => prev + element);\n\n","name":"fold","id":"fold2()","children":[{"name":"initialValue","id":"initialValue","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"combine","id":"combine","children":[{"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"uri":"sdk/lib/core/iterable.dart","name":"previousValue","id":"previousValue","line":"111","kind":"param"},{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"111","kind":"param"}],"line":"13","kind":"functiontype"}],"line":"111","kind":"param"}],"line":"110","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns true if every elements of this collection satisify the\npredicate [test]. Returns `false` otherwise.\n","name":"every","id":"every1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"117","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"117","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"comment":"\nConverts each element to a [String] and concatenates the strings.\n\nConverts each element to a [String] by calling [Object.toString] on it.\nThen concatenates the strings, optionally separated by the [separator]\nstring.\n","name":"join","id":"join1()","children":[{"ref":{"refId":"dart.core/String","name":"String"},"isOptional":true,"defaultValue":"\"\"","name":"separator","id":"separator","kind":"param"}],"line":"126","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns true if one element of this collection satisfies the\npredicate [test]. Returns false otherwise.\n","name":"any","id":"any1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"136","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"136","kind":"method"},{"returnType":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"List"},"comment":"\nCreates a [List] containing the elements of this [Iterable].\n\nThe elements will be in iteration order. The list is fixed-length\nif [growable] is false.\n","name":"toList","id":"toList1()","children":[{"isNamed":true,"ref":{"refId":"dart.core/bool","name":"bool"},"isOptional":true,"defaultValue":"true","name":"growable","id":"growable","kind":"param"}],"line":"144","kind":"method"},{"returnType":{"refId":"dart.core/Set","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Set"},"comment":"\nCreates a [Set] containing the elements of this [Iterable].\n","name":"toSet","id":"toSet0()","line":"149","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Iterable"},"comment":"\nReturns an [Iterable] with at most [n] elements.\n\nThe returned [Iterable] may contain fewer than [n] elements, if `this`\ncontains fewer than [n] elements.\n","name":"take","id":"take1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"n","id":"n","kind":"param"}],"line":"175","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Iterable"},"comment":"\nReturns an [Iterable] that stops once [test] is not satisfied anymore.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] will start iterating over the elements of `this`.\n\nWhen the iterator encounters an element `e` that does not satisfy [test],\nit discards `e` and moves into the finished state. That is, it will not\nask or provide any more elements.\n","name":"takeWhile","id":"takeWhile1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"value","id":"value","line":"187","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"187","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Iterable"},"comment":"\nReturns an [Iterable] that skips the first [n] elements.\n\nIf `this` has fewer than [n] elements, then the resulting [Iterable] will\nbe empty.\n","name":"skip","id":"skip1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"n","id":"n","kind":"param"}],"line":"195","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Iterable"},"comment":"\nReturns an [Iterable] that skips elements while [test] is satisfied.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] iterates over all elements of `this`.\n\nAs long as the iterator's elements satisfy [test] they are\ndiscarded. Once an element does not satisfy the [test] the iterator stops\ntesting and uses every later element unconditionally. That is, the elements\nof the returned [Iterable] are the elements of `this` starting from the\nfirst element that does not satisfy [test].\n","name":"skipWhile","id":"skipWhile1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"value","id":"value","line":"209","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"209","kind":"method"},{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReturns the first element that satisfies the given predicate [test].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is `null`, a [StateError] is\nthrown.\n","name":"firstWhere","id":"firstWhere2()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"240","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"name":"orElse","id":"orElse","children":[{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","line":"13","kind":"functiontype"}],"kind":"param"}],"line":"240","kind":"method"},{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReturns the last element that satisfies the given predicate [test].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is `null`, a [StateError] is\nthrown.\n","name":"lastWhere","id":"lastWhere2()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"249","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"name":"orElse","id":"orElse","children":[{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","line":"13","kind":"functiontype"}],"kind":"param"}],"line":"249","kind":"method"},{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReturns the single element that satisfies [test]. If no or more than one\nelement match then a [StateError] is thrown.\n","name":"singleWhere","id":"singleWhere1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/iterable.dart","name":"element","id":"element","line":"255","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"255","kind":"method"},{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReturns the [index]th element.\n\nIf `this` has fewer than [index] elements throws a [RangeError].\n\nNote: if `this` does not have a deterministic iteration order then the\nfunction may simply return any element without any iteration if there are\nat least [index] elements in `this`.\n","name":"elementAt","id":"elementAt1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"}],"line":"266","kind":"method"},{"ref":{"refId":"dart.core/Iterator","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Iterator"},"comment":"\nReturns an [Iterator] that iterates over this [Iterable] object.\n","name":"iterator","id":"iterator","line":"39","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nReturns the number of elements in [this].\n\nCounting all elements may be involve running through all elements and can\ntherefore be slow.\n","name":"length","id":"length","line":"157","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns true if there is no element in this collection.\n","name":"isEmpty","id":"isEmpty","line":"162","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturns true if there is at least one element in this collection.\n","name":"isNotEmpty","id":"isNotEmpty","line":"167","kind":"property"},{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReturns the first element.\n\nIf `this` is empty throws a [StateError]. Otherwise this method is\nequivalent to [:this.elementAt(0):]\n","name":"first","id":"first","line":"217","kind":"property"},{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReturns the last element.\n\nIf `this` is empty throws a [StateError].\n","name":"last","id":"last","line":"224","kind":"property"},{"ref":{"refId":"dart.core/Iterable/E","name":"E"},"comment":"\nReturns the single element in `this`.\n\nIf `this` is empty or has more than one element throws a [StateError].\n","name":"single","id":"single","line":"231","kind":"property"},{"name":"Iterable","id":"Iterable0()","line":"20","kind":"constructor"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/Iterable/E","name":"E"}],"name":"Iterable"},"comment":"\nCreate an [Iterable] that generates its elements dynamically.\n\nThe [Iterators] created by the [Iterable] will count from\nzero to [:count - 1:] while iterating, and call [generator]\nwith that index to create the next value.\n\nAs an [Iterable], [:new Iterable.generate(n, generator)):] is equivalent to\n[:const [0, ..., n - 1].map(generator):]\n","name":"Iterable.generate","id":"Iterable.generate2()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"count","id":"count","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"generator","id":"generator","children":[{"returnType":{"refId":"dart.core/Iterable/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.core/int","name":"int"},"uri":"sdk/lib/core/iterable.dart","name":"index","id":"index","line":"32","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"32","kind":"constructor"},{"name":"E","id":"E","kind":"typeparam"}],"line":"19","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"isThrowable":true,"comment":"\nA marker interface implemented by all core library exceptions.\n\nAn [Exception] is intended to convey information to the user about a failure,\nso that the error can be addressed programmatically. It is intended to be\ncaught, and it should contain useful data fields.\n\nCreating instances of [Exception] directly with [:new Exception(\"message\"):]\nis discouraged, and only included as a temporary measure during development,\nuntil the actual exceptions used by a library are done.\n","uri":"sdk/lib/core/exceptions.dart","name":"Exception","id":"Exception","children":[{"returnType":{"refId":"dart.core/Exception","name":"Exception"},"name":"Exception","id":"Exception1()","children":[{"isOptional":true,"name":"message","id":"message","kind":"param"}],"line":"21","kind":"constructor"}],"line":"20","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nInterface used by types that have an intrinsic ordering.\n","uri":"sdk/lib/core/comparable.dart","name":"Comparable","id":"Comparable","children":[{"returnType":{"refId":"dart.core/int","name":"int"},"comment":"\nCompares this object to another [Comparable]\n\nReturns a value like a [Comparator] when comparing [:this:] to [other].\n\nMay throw an [ArgumentError] if [other] is of a type that\nis not comparable to [:this:].\n","name":"compareTo","id":"compareTo1()","children":[{"ref":{"refId":"dart.core/Comparable/T","name":"T"},"name":"other","id":"other","kind":"param"}],"line":"35","kind":"method"},{"returnType":{"refId":"dart.core/int","name":"int"},"isStatic":true,"comment":"\nCompare one comparable to another.\n\nThis utility function is used as the default comparator\nfor the [List] sort function.\n","name":"compare","id":"compare2()","children":[{"ref":{"refId":"dart.core/Comparable","name":"Comparable"},"name":"a","id":"a","kind":"param"},{"ref":{"refId":"dart.core/Comparable","name":"Comparable"},"name":"b","id":"b","kind":"param"}],"line":"43","kind":"method"},{"name":"T","id":"T","kind":"typeparam"}],"line":"26","kind":"class"}],"line":"5","kind":"library"},{"uri":"sdk/lib/collection/collection.dart","name":"dart:collection","id":"dart.collection","children":[{"isAbstract":true,"interfaces":[{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"Iterable"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nBase class for implementing [Iterable].\n\nThis class implements all methods of [Iterable] except [Iterable.iterator]\nin terms of `iterator`.\n","uri":"sdk/lib/collection/iterable.dart","name":"IterableBase","id":"IterableBase","children":[{"returnType":{"refId":"dart.core/Iterable","name":"Iterable"},"name":"map","id":"map1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"207","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"207","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"Iterable"},"name":"where","id":"where1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"209","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"209","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","name":"Iterable"},"name":"expand","id":"expand1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"dart.core/Iterable","name":"Iterable"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"211","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"211","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"contains","id":"contains1()","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"element","id":"element","kind":"param"}],"line":"214","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"forEach","id":"forEach1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"void","name":"void"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"221","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"221","kind":"method"},{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"reduce","id":"reduce1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"combine","id":"combine","children":[{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"value","id":"value","line":"225","kind":"param"},{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"225","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"225","kind":"method"},{"name":"fold","id":"fold2()","children":[{"name":"initialValue","id":"initialValue","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"combine","id":"combine","children":[{"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"uri":"sdk/lib/collection/iterable.dart","name":"previousValue","id":"previousValue","line":"238","kind":"param"},{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"238","kind":"param"}],"line":"13","kind":"functiontype"}],"line":"238","kind":"param"}],"line":"237","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"every","id":"every1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"244","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"244","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"join","id":"join1()","children":[{"ref":{"refId":"dart.core/String","name":"String"},"isOptional":true,"name":"separator","id":"separator","kind":"param"}],"line":"251","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"any","id":"any1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"element","id":"element","line":"269","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"269","kind":"method"},{"returnType":{"refId":"dart.core/List","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"List"},"name":"toList","id":"toList1()","children":[{"isNamed":true,"ref":{"refId":"dart.core/bool","name":"bool"},"isOptional":true,"defaultValue":"true","name":"growable","id":"growable","kind":"param"}],"line":"276","kind":"method"},{"returnType":{"refId":"dart.core/Set","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"Set"},"name":"toSet","id":"toSet0()","line":"279","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"Iterable"},"name":"take","id":"take1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"n","id":"n","kind":"param"}],"line":"294","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"Iterable"},"name":"takeWhile","id":"takeWhile1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"value","id":"value","line":"298","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"298","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"Iterable"},"name":"skip","id":"skip1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"n","id":"n","kind":"param"}],"line":"302","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.collection/IterableBase/E","name":"E"}],"name":"Iterable"},"name":"skipWhile","id":"skipWhile1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"value","id":"value","line":"306","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"306","kind":"method"},{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"firstWhere","id":"firstWhere2()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"value","id":"value","line":"338","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"name":"orElse","id":"orElse","children":[{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","line":"13","kind":"functiontype"}],"kind":"param"}],"line":"338","kind":"method"},{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"lastWhere","id":"lastWhere2()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"value","id":"value","line":"347","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"name":"orElse","id":"orElse","children":[{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","line":"13","kind":"functiontype"}],"kind":"param"}],"line":"347","kind":"method"},{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"singleWhere","id":"singleWhere1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"test","id":"test","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"uri":"sdk/lib/collection/iterable.dart","name":"value","id":"value","line":"362","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"}],"line":"362","kind":"method"},{"returnType":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"elementAt","id":"elementAt1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"index","id":"index","kind":"param"}],"line":"379","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","line":"281","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"isEmpty","id":"isEmpty","line":"290","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"isNotEmpty","id":"isNotEmpty","line":"292","kind":"property"},{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"first","id":"first","line":"310","kind":"property"},{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"last","id":"last","line":"318","kind":"property"},{"ref":{"refId":"dart.collection/IterableBase/E","name":"E"},"name":"single","id":"single","line":"330","kind":"property"},{"name":"IterableBase","id":"IterableBase0()","line":"205","kind":"constructor"},{"name":"E","id":"E","kind":"typeparam"}],"line":"202","kind":"class"}],"line":"5","kind":"library"}],"comment":"\nThis provides a general-purpose serialization facility for Dart objects. A\n[Serialization] is defined in terms of [SerializationRule]s and supports\nreading and writing to different formats.\n\n## Installing ##\n\nUse [pub][] to install this package. Add the following to your `pubspec.yaml`\nfile.\n\n    dependencies:\n      serialization: any\n\nThen run `pub install`.\n\nFor more information, see the\n[serialization package on pub.dartlang.org][pkg].\n\nSetup\n=====\nA simple example of usage is\n\n     var address = new Address();\n     address.street = 'N 34th';\n     address.city = 'Seattle';\n     var serialization = new Serialization()\n         ..addRuleFor(address);\n     Map output = serialization.write(address);\n\nThis creates a new serialization and adds a rule for address objects. Right\nnow it has to be passed an address instance because of limitations using\nAddress as a literal. Then we ask the [Serialization] to write the address\nand we get back a Map which is a [json]able representation of the state of\nthe address and related objects. Note that while the output in this case\nis a [Map], the type will vary depending on which output format we've told\nthe [Serialization] to use.\n\nThe version above used reflection to automatically identify the public\nfields of the address object. We can also specify those fields explicitly.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"create\",\n           constructorFields: [\"number\", \"street\"],\n           fields: [\"city\"]);\n\nThis rule still uses reflection to access the fields, but does not try to\nidentify which fields to use, but instead uses only the \"number\" and \"street\"\nfields that we specified. We may also want to tell it to identify the\nfields, but to specifically omit certain fields that we don't want\nserialized.\n\n     var serialization = new Serialization()\n       ..addRuleFor(address,\n           constructor: \"\",\n           excludeFields: [\"other\", \"stuff\"]);\n\nWriting Rules\n=============\nWe can also use a completely non-reflective rule to serialize and\nde-serialize objects. This can be more work, but it does work in\ndart2js, where mirrors are not yet implemented. We can specify this in two\nways. First, we can write our own SerializationRule class that has methods\nfor our Address class.\n\n     class AddressRule extends CustomRule {\n       bool appliesTo(instance, Writer w) => instance.runtimeType == Address;\n       getState(instance) => [instance.street, instance.city];\n       create(state) => new Address();\n       setState(Address a, List state) {\n         a.street = state[0];\n         a.city = state[1];\n       }\n     }\n\nThe class needs four different methods. The [CustomRule.appliesTo]\nmethod tells us if\nthe rule should be used to write an object. In this example we use a test\nbased on runtimeType. We could also use an \"is Address\" test, but if Address\nhas subclasses that would find those as well, and we want a separate rule\nfor each. The [CustomRule.getState] method should\nreturn all the state of the object that we want to recreate,\nand should be either a Map or a List. If you want to write to human-readable\nformats where it's useful to be able to look at the data as a map from\nfield names to values, then it's better to return it as a map. Otherwise it's\nmore efficient to return it as a list. You just need to be sure that the\n[CustomRule.create] and [CustomRule.setState] methods interpret the data the\nsame way as [CustomRule.getState] does.\n\nThe [CustomRule.create] method will create the new object and return it. While it's\npossible to create the object and set all its state in this one method, that\nincreases the likelihood of problems with cycles. So it's better to use the\nminimum necessary information in [CustomRule.create] and do more of the work\nin [CustomRule.setState].\n\nThe other way to do this is not creating a subclass, but by using a\n[ClosureRule] and giving it functions for how to create\nthe address.\n\n     addressToMap(a) => {\"number\" : a.number, \"street\" : a.street,\n         \"city\" : a.city};\n     createAddress(Map m) => new Address.create(m[\"number\"], m[\"street\"]);\n     fillInAddress(Address a, Map m) => a.city = m[\"city\"];\n     var serialization = new Serialization()\n       ..addRule(\n           new ClosureRule(anAddress.runtimeType,\n               addressToMap, createAddress, fillInAddress);\n\nIn this case we have created standalone functions rather than\nmethods in a subclass and we pass them to the constructor of\n[ClosureRule]. In this case we've also had them use maps rather than\nlists for the state, but either would work as long as the rule is\nconsistent with the representation it uses. We pass it the runtimeType\nof the object, and functions equivalent to the methods on [CustomRule]\n\nConstant Values\n===============\nThere are cases where the constructor needs values that we can't easily get\nfrom the serialized object. For example, we may just want to pass null, or a\nconstant value. To support this, we can specify as constructor fields\nvalues that aren't field names. If any value isn't a String, or is a string\nthat doesn't correspond to a field name, it will be\ntreated as a constant and passed unaltered to the constructor.\n\nIn some cases a non-constructor field should not be set using field\naccess or a setter, but should be done by calling a method. For example, it\nmay not be possible to set a List field \"foo\", and you need to call an\naddFoo() method for each entry in the list. In these cases, if you are using\na BasicRule for the object you can call the setFieldWith() method.\n\n      s..addRuleFor(fooHolderInstance).setFieldWith(\"foo\",\n          (parent, value) => for (var each in value) parent.addFoo(value));\n\nWriting\n=======\nTo write objects, we use the write() method.\n\n      var output = serialization.write(someObject);\n\nBy default this uses a representation in which objects are represented as\nmaps keyed by field name, but in which references between objects have been\nconverted into Reference objects. This is then typically encoded as\na [json] string, but can also be used in other ways, e.g. sent to another\nisolate.\n\nWe can write objects in different formats by passing a [Format] object to\nthe [Serialization.write] method or by getting a [Writer] object.\nThe available formats\ninclude the default, a simple \"flat\" format that doesn't include field names,\nand a simple JSON format that produces output more suitable for talking to\nservices that expect JSON in a predefined format. Examples of these are\n\n     Map output = serialization.write(address, new SimpleMapFormat());\n     List output = serialization.write(address, new SimpleFlatFormat());\n     var output = serialization.write(address, new SimpleJsonFormat());\nOr, using a [Writer] explicitly\n     var writer = serialization.newWriter(new SimpleFlatFormat());\n     List output = writer.write(address);\n\nThese representations are not yet considered stable.\n\nReading\n=======\nTo read objects, the corresponding [Serialization.read] method can be used.\n\n      Address input = serialization.read(input);\n\nWhen reading, the serialization instance doing the reading must be configured\nwith compatible rules to the one doing the writing. It's possible for the\nrules to be different, but they need to be able to read the same\nrepresentation. For most practical purposes right now they should be the\nsame. The simplest way to achieve this is by having the serialization\nvariable [Serialization.selfDescribing] be true. In that case the rules\nthemselves are also\nstored along with the serialized data, and can be read back on the receiving\nend. Note that this may not work for all rules or all formats. The\n[Serialization.selfDescribing] variable is true by default, but the\n[SimpleJsonFormat] does not support it, since the point is to provide a\nrepresentation in a form\nother services might expect. Using CustomRule or ClosureRule also does not\nyet work with the [Serialization.selfDescribing] variable.\n\nNamed Objects\n=============\nWhen reading, some object references should not be serialized, but should be\nconnected up to other instances on the receiving side. A notable example of\nthis is when serialization rules have been stored. Instances of BasicRule\ntake a [ClassMirror] in their constructor, and we cannot serialize those. So\nwhen we read the rules, we must provide a Map<String, Object> which maps from\nthe simple name of classes we are interested in to a [ClassMirror]. This can\nbe provided either in the [Serialization.namedObjects],\nor as an additional parameter to the reading and writing methods on the\n[Reader] or [Writer] respectively.\n\n    new Serialization()\n      ..addRuleFor(new Person(), constructorFields: [\"name\"])\n      ..namedObjects['Person'] = reflect(new Person()).type;\n\n[pub]: http://pub.dartlang.org\n[pkg]: http://pub.dartlang.org/packages/serialization\n","uri":"pkg/serialization/lib/serialization.dart","name":"package:serialization/serialization.dart","id":"serialization","children":[{"returnType":{"refId":"dart.core/Symbol","name":"Symbol"},"comment":"\nReturn a symbol corresponding to [value], which may be a String or a\nSymbol. If it is any other type, or if the string is an\ninvalid symbol, return null;\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"_asSymbol","isPrivate":true,"id":"_asSymbol1()","children":[{"name":"value","id":"value","kind":"param"}],"line":"671","kind":"method"},{"comment":"Create a lazy list/map that will inflate its items on demand in [r]. ","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"_lazy","isPrivate":true,"id":"_lazy2()","children":[{"name":"l","id":"l","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"508","kind":"method"},{"superclass":{"refId":"serialization/Format","name":"Format"},"comment":"\nWrites to a simple mostly-flat format. Details are subject to change.\nRight now this produces a List containing null, num, and String. This is\nmore space-efficient than the map formats, but much less human-readable.\nSimple usage is to turn this into JSON for transmission.\n","uri":"pkg/serialization/lib/src/format.dart","name":"SimpleFlatFormat","id":"SimpleFlatFormat","children":[{"returnType":{"refId":"dart.core/List","name":"List"},"comment":"\nGenerate output for this format from [w]. This will return a List with\nthree entries, corresponding to the \"rules\", \"data\", and \"roots\" from\n[SimpleMapFormat]. The data is stored as a single List containing\nprimitives.\n","name":"generateOutput","id":"generateOutput1()","children":[{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"340","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nWrites the data from [rule] into the [target] list.\n","name":"writeStateInto","id":"writeStateInto3()","children":[{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"ruleData","id":"ruleData","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"target","id":"target","kind":"param"}],"line":"358","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nWrite [entries], which contains Lists. Either the lists are variable\nlength, in which case we add a length field, or they are fixed length, in\nwhich case we don't, and assume the [rule] will know how to read the\nright length when we read it back. We expect everything in the list to be\na reference, which is stored as two numbers.\n","name":"writeLists","id":"writeLists3()","children":[{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List","name":"List"}],"name":"List"},"name":"entries","id":"entries","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"target","id":"target","kind":"param"}],"line":"383","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nWrite [entries], which contains Maps. Either the Maps are variable\nlength, in which case we add a length field, or they are fixed length, in\nwhich case we don't, and assume the [rule] will know how to read the\nright length when we read it back. Then we write alternating keys and\nvalues. We expect the values to be references, which we store as\ntwo numbers.\n","name":"writeMaps","id":"writeMaps3()","children":[{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/Map","name":"Map"}],"name":"List"},"name":"entries","id":"entries","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"target","id":"target","kind":"param"}],"line":"403","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nWrite [entries], which contains simple objects which we can put directly\ninto [target].\n","name":"writeObjects","id":"writeObjects2()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"entries","id":"entries","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"target","id":"target","kind":"param"}],"line":"420","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nWrite [eachRef] to [target]. It will be written as two ints. If [eachRef]\nis null it will be written as two nulls.\n","name":"writeReference","id":"writeReference2()","children":[{"ref":{"refId":"serialization/Reference","name":"Reference"},"name":"eachRef","id":"eachRef","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"target","id":"target","kind":"param"}],"line":"432","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nRead the data from [rawInput] in the context of [r] and return it as a\nMap with entries for \"roots\", \"data\" and \"rules\", which the reader knows\nhow to interpret. We expect [rawInput] to have been generated from this\nformat.\n","name":"read","id":"read2()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"rawInput","id":"rawInput","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"447","kind":"method"},{"comment":"\nRead the data for [rule] from [input] and return it.\n","name":"readRuleDataFrom","id":"readRuleDataFrom3()","children":[{"ref":{"refId":"dart.core/Iterator","name":"Iterator"},"name":"input","id":"input","kind":"param"},{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"476","kind":"method"},{"comment":"\nRead data for [rule] from [input] with [length] number of entries,\ncreating lists from the results.\n","name":"readLists","id":"readLists4()","children":[{"ref":{"refId":"dart.core/Iterator","name":"Iterator"},"name":"input","id":"input","kind":"param"},{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"499","kind":"method"},{"comment":"\nRead data for [rule] from [input] with [length] number of entries,\ncreating maps from the results.\n","name":"readMaps","id":"readMaps4()","children":[{"ref":{"refId":"dart.core/Iterator","name":"Iterator"},"name":"input","id":"input","kind":"param"},{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"517","kind":"method"},{"comment":"\nRead data for [rule] from [input] with [length] number of entries,\ntreating the data as primitives that can be returned directly.\n","name":"readPrimitives","id":"readPrimitives3()","children":[{"ref":{"refId":"dart.core/Iterator","name":"Iterator"},"name":"input","id":"input","kind":"param"},{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","kind":"param"}],"line":"537","kind":"method"},{"returnType":{"refId":"serialization/Reference","name":"Reference"},"comment":"Read the next Reference from the input. ","name":"nextReferenceFrom","id":"nextReferenceFrom2()","children":[{"ref":{"refId":"dart.core/Iterator","name":"Iterator"},"name":"input","id":"input","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"546","kind":"method"},{"comment":"Return the next element from the input. ","name":"_next","isPrivate":true,"id":"_next1()","children":[{"ref":{"refId":"dart.core/Iterator","name":"Iterator"},"name":"input","id":"input","kind":"param"}],"line":"557","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"shouldUseReferencesForPrimitives","id":"shouldUseReferencesForPrimitives","line":"322","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"isStatic":true,"comment":"\nFor each rule we store data to indicate whether it will be reconstructed\nas a primitive, a list or a map.\n","name":"STORED_AS_LIST","id":"STORED_AS_LIST","line":"328","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isStatic":true,"name":"STORED_AS_MAP","id":"STORED_AS_MAP","line":"329","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isStatic":true,"name":"STORED_AS_PRIMITIVE","id":"STORED_AS_PRIMITIVE","line":"330","kind":"variable"},{"name":"SimpleFlatFormat","id":"SimpleFlatFormat0()","line":"332","kind":"constructor"}],"line":"321","kind":"class"},{"superclass":{"refId":"serialization/SimpleMapFormat","name":"SimpleMapFormat"},"comment":"\nA format for \"normal\" [json] representation of objects. It stores\nthe fields of the objects as nested maps, and doesn't allow cycles. This can\nbe useful in talking to existing APIs that expect [json] format data. The\noutput will be either a simple object (string, num, bool), a List, or a Map,\nwith nesting of those.\nNote that since the classes of objects aren't normally stored, this isn't\nenough information to read back the objects. However, if the\nIf the [storeRoundTripInfo] field of the format is set to true, then this\nwill store the rule number along with the data, allowing reconstruction.\n","uri":"pkg/serialization/lib/src/format.dart","name":"SimpleJsonFormat","id":"SimpleJsonFormat","children":[{"comment":"\nGenerate output for this format from [w] and return it as\nthe [json] representation of a nested Map structure.\n","name":"generateOutput","id":"generateOutput1()","children":[{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"200","kind":"method"},{"comment":"\nConvert the data generated by the rules to have nested maps instead\nof Reference objects and to add rule numbers if [storeRoundTripInfo]\nis true.\n","name":"jsonify","id":"jsonify1()","children":[{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"217","kind":"method"},{"comment":"\nFor a particular [rule] modify the [ruleData] to conform to this format.\n","name":"jsonifyForRule","id":"jsonifyForRule3()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"ruleData","id":"ruleData","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"},{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"}],"line":"227","kind":"method"},{"comment":"\nFor one particular entry, which is either a Map or a List, update it\nto turn References into a nested List/Map.\n","name":"jsonifyEntry","id":"jsonifyEntry2()","children":[{"name":"map","id":"map","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"244","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nRead serialized data saved in this format, which should look like\neither a simple type, a List or a Map and return the Map\nrepresentation that the reader expects, with top-level\nentries for \"rules\", \"data\", and \"roots\". Nested lists/maps will be\nconverted into Reference objects. Note that if the data was not written\nwith [storeRoundTripInfo] true this will fail.\n","name":"read","id":"read2()","children":[{"name":"data","id":"data","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"264","kind":"method"},{"comment":"\nConvert nested references in [input] into [Reference] objects.\n","name":"recursivelyFixUp","id":"recursivelyFixUp3()","children":[{"name":"input","id":"input","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"result","id":"result","kind":"param"}],"line":"288","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"isFinal":true,"comment":"\nIndicate if we should store rule numbers with map/list data so that we\nwill know how to reconstruct it with a read operation. If we don't, this\nwill be more compliant with things that expect known format JSON as input,\nbut we won't be able to read back the objects.\n","name":"storeRoundTripInfo","id":"storeRoundTripInfo","line":"184","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"isStatic":true,"comment":"\nIf we store the rule numbers, what key should we use to store them.\n","name":"RULE","id":"RULE","line":"189","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"isStatic":true,"name":"RULES","id":"RULES","line":"190","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"isStatic":true,"name":"DATA","id":"DATA","line":"191","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"isStatic":true,"name":"ROOTS","id":"ROOTS","line":"192","kind":"variable"},{"name":"SimpleJsonFormat","id":"SimpleJsonFormat1()","children":[{"initializedField":{"refId":"serialization/SimpleJsonFormat/storeRoundTripInfo","name":"storeRoundTripInfo"},"isNamed":true,"ref":{"refId":"dart.core/bool","name":"bool"},"isOptional":true,"defaultValue":"false","name":"storeRoundTripInfo","id":"storeRoundTripInfo","kind":"param"}],"line":"194","kind":"constructor"}],"line":"176","kind":"class"},{"superclass":{"refId":"serialization/InternalMapFormat","name":"InternalMapFormat"},"comment":"\nA format that stores the data in maps which can be converted into a JSON\nstring or passed through an isolate. Note that this consists of maps, but\nthat they don't follow the original object structure or look like the nested\nmaps of a [json] representation. They are flat, and [Reference] objects\nare converted into a map form that will not make sense to\nanything but this format. For simple acyclic JSON that other programs\ncan read, use [SimpleJsonFormat]. This is the default format, and is\neasier to read than the more efficient [SimpleFlatFormat].\n","uri":"pkg/serialization/lib/src/format.dart","name":"SimpleMapFormat","id":"SimpleMapFormat","children":[{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nGenerate output for this format from [w] and return it as a String which\nis the [json] representation of a nested Map structure. The top level has\n3 fields, \"rules\" which may hold a definition of the rules used,\n\"data\" which holds the serialized data, and \"roots\", which holds\n[Reference] objects indicating the root objects. Note that roots are\nnecessary because the data is not organized in the same way as the object\nstructure, it's a list of lists holding self-contained maps which only\nrefer to other parts via [Reference] objects.\nThis effectively defines a custom JSON serialization format, although\nthe details of the format vary depending which rules were used.\n","name":"generateOutput","id":"generateOutput1()","children":[{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"105","kind":"method"},{"comment":"\nConvert the data generated by the rules to have maps with the fields\nof [Reference] objects instead of the [Reference] so that the structure\ncan be serialized between isolates and json easily.\n","name":"forAllStates","id":"forAllStates3()","children":[{"ref":{"refId":"serialization/ReaderOrWriter","name":"ReaderOrWriter"},"name":"w","id":"w","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"predicate","id":"predicate","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"uri":"pkg/serialization/lib/src/format.dart","name":"value","id":"value","line":"118","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"transform","id":"transform","children":[{"returnType":{"refId":"void","name":"void"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"uri":"pkg/serialization/lib/src/format.dart","name":"value","id":"value","line":"119","kind":"param"}],"line":"13","kind":"functiontype"}],"line":"119","kind":"param"}],"line":"118","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"},{"refId":"dart.core/int","name":"int"}],"name":"Map"},"comment":"Convert the reference to a [json] serializable form. ","name":"referenceToMap","id":"referenceToMap1()","children":[{"ref":{"refId":"serialization/Reference","name":"Reference"},"name":"ref","id":"ref","kind":"param"}],"line":"133","kind":"method"},{"returnType":{"refId":"serialization/Reference","name":"Reference"},"comment":"\nConvert the [referenceToMap] form for a reference back to a [Reference]\nobject.\n","name":"mapToReference","id":"mapToReference2()","children":[{"ref":{"refId":"serialization/ReaderOrWriter","name":"ReaderOrWriter"},"name":"parent","id":"parent","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"},{"refId":"dart.core/int","name":"int"}],"name":"Map"},"name":"ref","id":"ref","kind":"param"}],"line":"144","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nRead serialized data written in this format\nand return the nested Map representation described in [generateOutput]. If\nthe data also includes rule definitions, then these will replace the rules\nin the [Serialization] for [reader].\n","name":"read","id":"read2()","children":[{"name":"topLevel","id":"topLevel","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"153","kind":"method"},{"name":"SimpleMapFormat","id":"SimpleMapFormat0()","line":"91","kind":"constructor"}],"line":"89","kind":"class"},{"superclass":{"refId":"serialization/Format","name":"Format"},"comment":"\nThis is the most basic format, which provides the internal representation\nof the serialization, exposing the Reference objects.\n","uri":"pkg/serialization/lib/src/format.dart","name":"InternalMapFormat","id":"InternalMapFormat","children":[{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nGenerate output for this format from [w] and return it as a nested Map\nstructure. The top level has\n3 fields, \"rules\" which may hold a definition of the rules used,\n\"data\" which holds the serialized data, and \"roots\", which holds\n[Reference] objects indicating the root objects. Note that roots are\nnecessary because the data is not organized in the same way as the object\nstructure, it's a list of lists holding self-contained maps which only\nrefer to other parts via [Reference] objects.\n","name":"generateOutput","id":"generateOutput1()","children":[{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"55","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nRead serialized data written from this format\nand return the nested Map representation described in [generateOutput]. If\nthe data also includes rule definitions, then these will replace the rules\nin the [Serialization] for [reader].\n","name":"read","id":"read2()","children":[{"name":"topLevel","id":"topLevel","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"70","kind":"method"},{"name":"InternalMapFormat","id":"InternalMapFormat0()","line":"43","kind":"constructor"}],"line":"42","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn abstract class for serialization formats. Subclasses define how data\nis read or written to a particular output mechanism.\n","uri":"pkg/serialization/lib/src/format.dart","name":"Format","id":"Format","children":[{"comment":"\nGenerate output for [w] and return it. The particular form of the output\nwill depend on the format. The format can assume that [w] has data\ngenerated by rules in a series of lists, and that each list will contain\neither primitives (null, bool, num, String), Lists or Maps. The Lists or\nMaps may contain any of the same things recursively, or may contain\nReference objects. For lists and maps the rule will tell us if they can\nbe of variable length or not. The format is allowed to operate\ndestructively on the rule data.\n","name":"generateOutput","id":"generateOutput1()","children":[{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"28","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nRead the data from [input] in the context of [reader] and return it as a\nMap with entries for \"roots\", \"data\" and \"rules\", which the reader knows\nhow to interpret. The type of [input] will depend on the particular format.\n","name":"read","id":"read2()","children":[{"name":"input","id":"input","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"35","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if this format stores primitives in their own area and uses\nreferences to them (e.g. [SimpleFlatFormat]) and false if primitives\nare stored directly (e.g. [SimpleJsonFormat], [SimpleMapFormat]).\n","name":"shouldUseReferencesForPrimitives","id":"shouldUseReferencesForPrimitives","line":"16","kind":"property"},{"name":"Format","id":"Format0()","line":"9","kind":"constructor"}],"line":"7","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis wraps a map to make it indexable by integer field numbers. It translates\nfrom the index into a field name and then looks it up in the map.\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"_MapWrapper","isPrivate":true,"id":"_MapWrapper","children":[{"isOperator":true,"name":"[]","id":"[]1()","children":[{"name":"key","id":"key","kind":"param"}],"line":"658","kind":"method"},{"isOperator":true,"name":"[]=","id":"[]=2()","children":[{"name":"key","id":"key","kind":"param"},{"name":"value","id":"value","kind":"param"}],"line":"660","kind":"method"},{"returnType":{"refId":"dart.core/Map","name":"Map"},"name":"asMap","id":"asMap0()","line":"663","kind":"method"},{"name":"length","id":"length","line":"661","kind":"property"},{"ref":{"refId":"dart.core/Map","name":"Map"},"isFinal":true,"name":"_map","isPrivate":true,"id":"_map","line":"653","kind":"variable"},{"ref":{"refId":"dart.core/List","name":"List"},"isFinal":true,"name":"fieldList","id":"fieldList","line":"654","kind":"variable"},{"name":"_MapWrapper","id":"_MapWrapper1()","children":[{"initializedField":{"refId":"serialization/_MapWrapper/fieldList","name":"fieldList"},"ref":{"refId":"dart.core/List","name":"List"},"name":"fieldList","id":"fieldList","kind":"param"}],"line":"655","kind":"constructor"},{"name":"_MapWrapper.fromMap","id":"_MapWrapper.fromMap2()","children":[{"initializedField":{"refId":"serialization/_MapWrapper/_map","name":"_map"},"ref":{"refId":"dart.core/Map","name":"Map"},"name":"_map","isPrivate":true,"id":"_map","kind":"param"},{"initializedField":{"refId":"serialization/_MapWrapper/fieldList","name":"fieldList"},"ref":{"refId":"dart.core/List","name":"List"},"name":"fieldList","id":"fieldList","kind":"param"}],"line":"656","kind":"constructor"}],"line":"652","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis represents a constructor that is to be used when re-creating a\nserialized object.\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"Constructor","id":"Constructor","children":[{"comment":"\nFind the field values in [state] and pass them to the constructor.\nIf any of [fieldNumbers] is not an int, then use it as a literal value.\n","name":"constructFrom","id":"constructFrom2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"632","kind":"method"},{"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"isFinal":true,"comment":"The mirror of the class we construct. ","name":"type","id":"type","line":"605","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"comment":"The name of the constructor to use, if not the default constructor.","name":"name","id":"name","line":"608","kind":"variable"},{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"nameSymbol","id":"nameSymbol","line":"609","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/int","name":"int"}],"name":"List"},"comment":"\nThe indices of the fields used as constructor arguments. We will look\nthese up in the state by number. The index is according to a list of the\nfields in alphabetical order by name.\n","name":"fieldNumbers","id":"fieldNumbers","line":"616","kind":"variable"},{"comment":"\nCreates a new constructor for the [type] with the constructor named [name]\nand the [fieldNumbers] of the constructor fields.\n","name":"Constructor","id":"Constructor3()","children":[{"initializedField":{"refId":"serialization/Constructor/type","name":"type"},"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"name":"type","id":"type","kind":"param"},{"initializedField":{"refId":"serialization/Constructor/name","name":"name"},"ref":{"refId":"dart.core/String","name":"String"},"name":"name","id":"name","kind":"param"},{"initializedField":{"refId":"serialization/Constructor/fieldNumbers","name":"fieldNumbers"},"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/int","name":"int"}],"name":"List"},"name":"fieldNumbers","id":"fieldNumbers","kind":"param"}],"line":"622","kind":"constructor"}],"line":"603","kind":"class"},{"comment":"\n Provide a typedef for the setWith argument to setFieldWith. It would\nbe nice if we could put this closer to the definition.\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"SetWithFunction","id":"SetWithFunction","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"m","id":"m","kind":"param"},{"name":"object","id":"object","kind":"param"}],"line":"597","kind":"typedef"},{"superclass":{"refId":"dart.collection/IterableBase","arguments":[{"refId":"serialization/_Field","name":"_Field"}],"name":"IterableBase"},"comment":"\nThe organization of fields in an object can be reasonably complex, so they\nare kept in a separate object, which also has the ability to compute the\ndefault fields to use reflectively.\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"_FieldList","isPrivate":true,"id":"_FieldList","children":[{"returnType":{"refId":"serialization/_Field","name":"_Field"},"comment":"Look up a field by [name]. ","name":"named","id":"named1()","children":[{"name":"name","id":"name","kind":"param"}],"line":"462","kind":"method"},{"isSetter":true,"comment":"Set the fields to be used in the constructor. ","name":"constructorFields=","id":"constructorFields=1()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"fieldNames","id":"fieldNames","kind":"param"}],"line":"465","kind":"method"},{"isSetter":true,"comment":"Set the fields that aren't used in the constructor. ","name":"regular=","id":"regular=1()","children":[{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"List"},"name":"fields","id":"fields","kind":"param"}],"line":"479","kind":"method"},{"isSetter":true,"comment":"Set the fields to be excluded. This is mutually exclusive with setting\nthe regular fields.\n","name":"exclude=","id":"exclude=1()","children":[{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"List"},"name":"fields","id":"fields","kind":"param"}],"line":"488","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Add all the fields which aren't on the exclude list. ","name":"addAllNotExplicitlyExcluded","id":"addAllNotExplicitlyExcluded1()","children":[{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Iterable"},"name":"aCollection","id":"aCollection","kind":"param"}],"line":"500","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Add all the fields with the given names without any special properties. ","name":"addAllByName","id":"addAllByName1()","children":[{"ref":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Iterable"},"name":"names","id":"names","kind":"param"}],"line":"508","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nFields have been added. In case we had already forced calculation of the\nlist of contents, re-set it.\n","name":"invalidate","id":"invalidate0()","line":"521","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Iterate over the regular fields, i.e. those not used in the constructor.","name":"forEachRegularField","id":"forEachRegularField1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","kind":"param"}],"line":"539","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Iterate over the fields used in the constructor. ","name":"forEachConstructorField","id":"forEachConstructorField1()","children":[{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","kind":"param"}],"line":"548","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"name":"constructorFieldNames","id":"constructorFieldNames0()","line":"557","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"name":"constructorFieldIndices","id":"constructorFieldIndices0()","line":"559","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"name":"regularFields","id":"regularFields0()","line":"561","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"name":"regularFieldNames","id":"regularFieldNames0()","line":"562","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"name":"regularFieldIndices","id":"regularFieldIndices0()","line":"563","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nIf we weren't given any non-constructor fields to use, figure out what\nwe think they ought to be, based on the class definition.\nWe find public fields, getters that have corresponding setters, and getters\nthat are listed in the constructor fields.\n","name":"figureOutFields","id":"figureOutFields0()","line":"572","kind":"method"},{"name":"toString","id":"toString0()","line":"590","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","line":"497","kind":"property"},{"ref":{"refId":"dart.core/Iterator","arguments":[{"refId":"serialization/_Field","name":"_Field"}],"name":"Iterator"},"name":"iterator","id":"iterator","line":"526","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"serialization/_Field","name":"_Field"}],"name":"List"},"comment":"Return a cached, sorted list of all the fields. ","name":"contents","id":"contents","line":"529","kind":"property"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"constructorFields","id":"constructorFields","line":"556","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"serialization/_Field","name":"_Field"}],"name":"Map"},"comment":"\nAll of our fields, indexed by name. Note that the names are\ntypically Symbols, but can also be arbitrary constants.\n","name":"allFields","id":"allFields","line":"438","kind":"variable"},{"ref":{"refId":"dart.core/List","name":"List"},"comment":"\nThe fields which are used in the constructor. The fields themselves also\nknow if they are constructor fields or not, but we need to keep this\ninformation here because the order matters.\n","name":"_constructorFields","isPrivate":true,"id":"_constructorFields","line":"445","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"}],"name":"List"},"comment":"The list of fields to exclude if we are computing the list ourselves. ","name":"_excludedFieldNames","isPrivate":true,"id":"_excludedFieldNames","line":"448","kind":"variable"},{"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"isFinal":true,"comment":"The mirror we will use to compute the fields. ","name":"mirror","id":"mirror","line":"451","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"serialization/_Field","name":"_Field"}],"name":"List"},"comment":"Cached, sorted list of fields. ","name":"_contents","isPrivate":true,"id":"_contents","line":"454","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"Should we compute the fields or just use whatever we were given. ","name":"_shouldFigureOutFields","isPrivate":true,"id":"_shouldFigureOutFields","line":"457","kind":"variable"},{"name":"_FieldList","id":"_FieldList1()","children":[{"initializedField":{"refId":"serialization/_FieldList/mirror","name":"mirror"},"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"name":"mirror","id":"mirror","kind":"param"}],"line":"459","kind":"constructor"}],"line":"433","kind":"class"},{"superclass":{"refId":"serialization/_Field","name":"_Field"},"comment":"\nThis represents a constant value that will be passed as a constructor\nparameter. Rather than having a name it has a constant value.\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"_ConstantField","isPrivate":true,"id":"_ConstantField","children":[{"isOperator":true,"name":"==","id":"==1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"414","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"416","kind":"method"},{"name":"valueIn","id":"valueIn1()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"mirror","id":"mirror","kind":"param"}],"line":"417","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"We cannot be set, so setValue is a no-op. ","name":"setValue","id":"setValue2()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"object","id":"object","kind":"param"},{"name":"value","id":"value","kind":"param"}],"line":"420","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"hashCode","id":"hashCode","line":"415","kind":"property"},{"comment":"There are places where the code expects us to have an identifier, so\nuse the value for that.\n","name":"name","id":"name","line":"425","kind":"property"},{"isFinal":true,"comment":"The value we always return.","name":"value","id":"value","line":"410","kind":"variable"},{"name":"_ConstantField._internal","isPrivate":true,"id":"_ConstantField._internal2()","children":[{"initializedField":{"refId":"serialization/_ConstantField/value","name":"value"},"name":"value","id":"value","kind":"param"},{"name":"fieldList","id":"fieldList","kind":"param"}],"line":"412","kind":"constructor"}],"line":"407","kind":"class"},{"superclass":{"refId":"serialization/_Field","name":"_Field"},"comment":"\nThis represents a field in the object, either stored as a field or\naccessed via getter/setter/constructor parameter. It has a name and\nwill attempt to access the state for that name using an [InstanceMirror].\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"_NamedField","isPrivate":true,"id":"_NamedField","children":[{"isOperator":true,"name":"==","id":"==1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"374","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Set the [value] of our field in the given mirrored [object]. ","name":"setValue","id":"setValue2()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"object","id":"object","kind":"param"},{"name":"value","id":"value","kind":"param"}],"line":"385","kind":"method"},{"name":"valueIn","id":"valueIn1()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"mirror","id":"mirror","kind":"param"}],"line":"389","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"The default setter function. ","name":"defaultSetter","id":"defaultSetter2()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"object","id":"object","kind":"param"},{"name":"value","id":"value","kind":"param"}],"line":"396","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"400","kind":"method"},{"ref":{"refId":"dart.core/String","name":"String"},"name":"name","id":"name","line":"371","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"hashCode","id":"hashCode","line":"375","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if this field is treated as essential state, either because\nit is used in the constructor, or because it's been designated\nusing [BasicRule.setFieldWith].\n","name":"isEssential","id":"isEssential","line":"382","kind":"property"},{"ref":{"refId":"dart.core/Function","name":"Function"},"comment":"Return the function to use to set our value. ","name":"setter","id":"setter","line":"392","kind":"property"},{"ref":{"refId":"dart.core/String","name":"String"},"comment":"The name of the field (or getter) ","name":"_name","isPrivate":true,"id":"_name","line":"355","kind":"variable"},{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"nameSymbol","id":"nameSymbol","line":"356","kind":"variable"},{"ref":{"refId":"dart.core/Function","name":"Function"},"comment":"\nIf this is set, then it is used as a way to set the value rather than\nusing the default mechanism.\n","name":"customSetter","id":"customSetter","line":"362","kind":"variable"},{"name":"_NamedField._internal","isPrivate":true,"id":"_NamedField._internal2()","children":[{"name":"fieldName","id":"fieldName","kind":"param"},{"name":"fieldList","id":"fieldList","kind":"param"}],"line":"364","kind":"constructor"}],"line":"353","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.core/Comparable","arguments":[{"refId":"serialization/_Field","name":"_Field"}],"name":"Comparable"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis represents a field in an object. It is intended to be used as part of\na [_FieldList].\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"_Field","isPrivate":true,"id":"_Field","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"isStatic":true,"comment":"\nDetermine if [value] represents a field or getter in the class that\n[fieldList] models.\n","name":"_isReallyAField","isPrivate":true,"id":"_isReallyAField2()","children":[{"name":"value","id":"value","kind":"param"},{"ref":{"refId":"serialization/_FieldList","name":"_FieldList"},"name":"fieldList","id":"fieldList","kind":"param"}],"line":"312","kind":"method"},{"comment":"\nExtracts the value for the field that this represents from the instance\nmirrored by [mirror] and return it.\n","name":"valueIn","id":"valueIn1()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"mirror","id":"mirror","kind":"param"}],"line":"325","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Set the [value] of our field in the given mirrored [object]. ","name":"setValue","id":"setValue2()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"object","id":"object","kind":"param"},{"name":"value","id":"value","kind":"param"}],"line":"340","kind":"method"},{"returnType":{"refId":"dart.core/int","name":"int"},"name":"compareTo","id":"compareTo1()","children":[{"ref":{"refId":"serialization/_Field","name":"_Field"},"name":"x","id":"x","kind":"param"}],"line":"345","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"Return true if this is field is not used in the constructor. ","name":"isRegular","id":"isRegular","line":"330","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if this field is treated as essential state, either because\nit is used in the constructor, or because it's been designated\nusing [BasicRule.setFieldWith].\n","name":"isEssential","id":"isEssential","line":"337","kind":"property"},{"ref":{"refId":"serialization/_FieldList","name":"_FieldList"},"isFinal":true,"comment":"The FieldList that contains us. ","name":"fieldList","id":"fieldList","line":"284","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nOur position in the [fieldList._contents] collection. This is used\nto index into the state, so it's extremely important.\n","name":"index","id":"index","line":"290","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"Is this field used in the constructor? ","name":"usedInConstructor","id":"usedInConstructor","line":"293","kind":"variable"},{"returnType":{"refId":"serialization/_Field","name":"_Field"},"comment":"\nCreate a new [_Field] instance. This will be either a [_NamedField] or a\n[_ConstantField] depending on whether or not [value] corresponds to a\nfield in the class which [fieldList] models.\n","name":"_Field","id":"_Field2()","children":[{"name":"value","id":"value","kind":"param"},{"ref":{"refId":"serialization/_FieldList","name":"_FieldList"},"name":"fieldList","id":"fieldList","kind":"param"}],"line":"300","kind":"constructor"},{"comment":"Private constructor. ","name":"_Field._internal","isPrivate":true,"id":"_Field._internal1()","children":[{"initializedField":{"refId":"serialization/_Field/fieldList","name":"fieldList"},"ref":{"refId":"serialization/_FieldList","name":"_FieldList"},"name":"fieldList","id":"fieldList","kind":"param"}],"line":"319","kind":"constructor"}],"line":"281","kind":"class"},{"superclass":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"\nThis is the basic rule for handling \"normal\" objects, which have a list of\nfields and a constructor, as opposed to simple types or collections. It uses\nmirrors to access the state, and can also use them to figure out the list\nof fields and the constructor if it's not provided.\n\nIf you call [Serialization.addRule], this is what you get.\n\n","uri":"pkg/serialization/lib/src/basic_rule.dart","name":"BasicRule","id":"BasicRule","children":[{"returnType":{"refId":"void","name":"void"},"comment":"\nSometimes it's necessary to treat fields of an object differently, based\non the containing object. For example, by default a list treats its\ncontents as non-essential state, so it will be populated only after all\nobjects have been created. An object may have a list which is used in its\nconstructor and must be fully created before the owning object can be\ncreated. Alternatively, it may not be possible to set a field directly,\nand some other method must be called to set it, perhaps calling a method\non the owning object to add each individual element.\n\nThis method lets you designate a function to use to set the value of a\nfield. It also makes the contents of that field be treated as essential,\nwhich currently only has meaning if the field is a list. This is done\nbecause you might set a list field's special treatment function to add\neach item individually and that will only work if those objects already\nexist.\n\nFor example, to serialize a Serialization, we need its rules to be\nindividually added rather than just setting the rules field.\n     ..addRuleFor(new Serialization()).setFieldWith('rules',\n         (InstanceMirror s, List rules) {\n           rules.forEach((x) => s.reflectee.addRule(x));\nNote that the function is passed the owning object as well as the field\nvalue, but that it is passed as a mirror.\n","name":"setFieldWith","id":"setFieldWith2()","children":[{"ref":{"refId":"dart.core/String","name":"String"},"name":"fieldName","id":"fieldName","kind":"param"},{"ref":{"refId":"serialization/SetWithFunction","name":"SetWithFunction"},"name":"setWith","id":"setWith","kind":"param"}],"line":"95","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"111","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nConfigure this instance to use maps by field name as its output.\nInstances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","name":"configureForMaps","id":"configureForMaps0()","line":"119","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nConfigure this instance to use lists accessing fields by index as its\noutput. Instances can either produce maps or lists. The list representation\nis much more compact and used by default. The map representation is\nmuch easier to debug. The default is to use lists.\n","name":"configureForLists","id":"configureForLists0()","line":"129","kind":"method"},{"comment":"\nCreate either a list or a map to hold the object's state, depending\non the [useMaps] variable. If using a Map, we wrap it in order to keep\nthe protocol compatible. See [configureForLists]/[configureForMaps].\n\nIf a list is returned, it is growable.\n","name":"createStateHolder","id":"createStateHolder0()","line":"140","kind":"method"},{"comment":"\nWrap the state if it's passed in as a map, and if the keys are references,\nresolve them to the strings we expect. We leave the previous keys in there\nas well, as they shouldn't be harmful, and it costs more to remove them.\n","name":"makeIndexableByNumber","id":"makeIndexableByNumber1()","children":[{"name":"state","id":"state","kind":"param"}],"line":"152","kind":"method"},{"comment":"\nExtract the state from [object] using an instanceMirror and the field\nnames in [_fields]. Call the function [callback] on each value.\n","name":"extractState","id":"extractState3()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"callback","id":"callback","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"171","kind":"method"},{"name":"flatten","id":"flatten2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"185","kind":"method"},{"comment":"\nIf the value is a List, and the field is a constructor field or\notherwise specially designated, we wrap it in something that indicates\na restriction on the rules that can be used. Which in this case amounts\nto designating the rule, since we so far only have one rule per object.\n","name":"checkForEssentialLists","id":"checkForEssentialLists2()","children":[{"name":"index","id":"index","kind":"param"},{"name":"value","id":"value","kind":"param"}],"line":"205","kind":"method"},{"comment":"Remove any MapWrapper from the extracted state. ","name":"_unwrap","isPrivate":true,"id":"_unwrap1()","children":[{"name":"result","id":"result","kind":"param"}],"line":"215","kind":"method"},{"comment":"\nCall the designated constructor with the appropriate fields from [state],\nfirst resolving references in the context of [reader].\n","name":"inflateEssential","id":"inflateEssential2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"221","kind":"method"},{"comment":"For all [rawState] not required in the constructor, set it in the\n[object], resolving references in the context of [reader].\n","name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"name":"rawState","id":"rawState","kind":"param"},{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"230","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nDetermine if this rule applies to the object in question. In our case\nthis is true if the type mirrors are the same.\n","name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"244","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nGiven the various field lists provided by the user, construct the list\nof field names that we want.\n","name":"_findFields","isPrivate":true,"id":"_findFields3()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"constructorFields","id":"constructorFields","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"regularFields","id":"regularFields","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"excludeFields","id":"excludeFields","line":"251","kind":"param"}],"line":"250","kind":"method"},{"comment":"\nExtract the value of [field] from the object reflected\nby [mirror].\n","name":"_value","isPrivate":true,"id":"_value2()","children":[{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"mirror","id":"mirror","kind":"param"},{"ref":{"refId":"serialization/_Field","name":"_Field"},"name":"field","id":"field","kind":"param"}],"line":"274","kind":"method"},{"ref":{"refId":"dart.core/String","name":"String"},"comment":"Return the name of the constructor used to create new instances on read.","name":"constructorName","id":"constructorName","line":"103","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"List"},"comment":"Return the list of field names to be passed to the constructor.","name":"constructorFields","id":"constructorFields","line":"106","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"List"},"comment":"Return the list of field names not used in the constructor. ","name":"regularFields","id":"regularFields","line":"109","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"260","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"dataLength","id":"dataLength","line":"262","kind":"property"},{"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"isFinal":true,"comment":"\nThe [type] is used both to find fields and to verify if the object is one\nthat we handle.\n","name":"type","id":"type","line":"25","kind":"variable"},{"ref":{"refId":"serialization/Constructor","name":"Constructor"},"comment":"Used to create new objects when reading. ","name":"constructor","id":"constructor","line":"28","kind":"variable"},{"ref":{"refId":"serialization/_FieldList","name":"_FieldList"},"comment":"This holds onto our list of fields, and can also calculate them. ","name":"_fields","isPrivate":true,"id":"_fields","line":"31","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nInstances can either use maps or lists to hold the object's state. The list\nrepresentation is much more compact and used by default. The map\nrepresentation is more human-readable. The default is to use lists.\n","name":"useMaps","id":"useMaps","line":"38","kind":"variable"},{"comment":"\nCreate this rule. Right now the user is obliged to pass a ClassMirror,\nbut once we allow class literals (Issue 6282) it will support that. The\nother parameters can all be left as null, and are optional on the\n[Serialization.addRule] method which is the normal caller for this.\n[constructorName] is the constructor, if not the default.\n[constructorFields] are the fields required to call the constructor, which\n  is the essential state. They don't have to be actual fields,\n  getter/setter pairs or getter/constructor pairs are fine. Note that\n  the constructorFields do not need to be strings, they can be arbitrary\n  values. For non-strings, these will be treated as constant values to be\n  used instead of data read from the objects.\n[regularFields] are the non-essential fields. They don't have to be actual\n  fields, getter/setter pairs are fine. If this is null, it's assumed\n  that we should figure them out.\n[excludeFields] lets you tell it to find the fields automatically, but\n  omit some that would otherwise be included.\n","name":"BasicRule","id":"BasicRule5()","children":[{"initializedField":{"refId":"serialization/BasicRule/type","name":"type"},"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"name":"type","id":"type","kind":"param"},{"ref":{"refId":"dart.core/String","name":"String"},"name":"constructorName","id":"constructorName","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"constructorFields","id":"constructorFields","line":"62","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"regularFields","id":"regularFields","line":"62","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"excludeFields","id":"excludeFields","line":"63","kind":"param"}],"line":"61","kind":"constructor"}],"line":"20","kind":"class"},{"interfaces":[{"refId":"dart.core/List","name":"List"}],"superclass":{"refId":"dart.collection/IterableBase","name":"IterableBase"},"comment":"\nThis provides an implementation of List that wraps a list which may\ncontain references to (potentially) non-inflated objects. If these\nare accessed it will inflate them. This allows us to pass something that\nlooks like it's just a list of objects to a [CustomRule] without needing\nto inflate all the references in advance.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"_LazyList","isPrivate":true,"id":"_LazyList","children":[{"isOperator":true,"name":"[]","id":"[]1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"567","kind":"method"},{"name":"indexOf","id":"indexOf2()","children":[{"name":"x","id":"x","kind":"param"},{"isOptional":true,"defaultValue":"0","name":"pos","id":"pos","kind":"param"}],"line":"579","kind":"method"},{"name":"lastIndexOf","id":"lastIndexOf2()","children":[{"name":"x","id":"x","kind":"param"},{"isOptional":true,"name":"pos","id":"pos","kind":"param"}],"line":"580","kind":"method"},{"name":"sublist","id":"sublist2()","children":[{"name":"start","id":"start","kind":"param"},{"isOptional":true,"name":"end","id":"end","kind":"param"}],"line":"581","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/int","name":"int"}],"name":"Map"},"name":"asMap","id":"asMap0()","line":"583","kind":"method"},{"name":"_throw","isPrivate":true,"id":"_throw0()","line":"586","kind":"method"},{"isOperator":true,"name":"[]=","id":"[]=2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"589","kind":"method"},{"name":"add","id":"add1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"590","kind":"method"},{"name":"addAll","id":"addAll1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"591","kind":"method"},{"name":"sort","id":"sort1()","children":[{"isOptional":true,"name":"f","id":"f","kind":"param"}],"line":"592","kind":"method"},{"name":"clear","id":"clear0()","line":"593","kind":"method"},{"name":"insert","id":"insert2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"594","kind":"method"},{"name":"insertAll","id":"insertAll2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"595","kind":"method"},{"name":"fillRange","id":"fillRange3()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"},{"isOptional":true,"name":"z","id":"z","kind":"param"}],"line":"596","kind":"method"},{"name":"removeAt","id":"removeAt1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"597","kind":"method"},{"name":"remove","id":"remove1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"598","kind":"method"},{"name":"removeLast","id":"removeLast0()","line":"599","kind":"method"},{"name":"removeAll","id":"removeAll1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"600","kind":"method"},{"name":"retainAll","id":"retainAll1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"601","kind":"method"},{"name":"removeWhere","id":"removeWhere1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"602","kind":"method"},{"name":"retainWhere","id":"retainWhere1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"603","kind":"method"},{"name":"replaceRange","id":"replaceRange3()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"},{"name":"z","id":"z","kind":"param"}],"line":"604","kind":"method"},{"name":"getRange","id":"getRange2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"605","kind":"method"},{"name":"setRange","id":"setRange4()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"},{"name":"z","id":"z","kind":"param"},{"isOptional":true,"defaultValue":"0","name":"a","id":"a","kind":"param"}],"line":"606","kind":"method"},{"name":"setAll","id":"setAll2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"607","kind":"method"},{"name":"removeRange","id":"removeRange2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"608","kind":"method"},{"returnType":{"refId":"void","name":"void"},"isSetter":true,"name":"length=","id":"length=1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"610","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","line":"569","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"isEmpty","id":"isEmpty","line":"570","kind":"property"},{"name":"first","id":"first","line":"571","kind":"property"},{"name":"last","id":"last","line":"572","kind":"property"},{"ref":{"refId":"dart.core/Iterable","name":"Iterable"},"name":"_inflated","isPrivate":true,"id":"_inflated","line":"577","kind":"property"},{"ref":{"refId":"dart.core/Iterator","name":"Iterator"},"name":"iterator","id":"iterator","line":"578","kind":"property"},{"name":"reversed","id":"reversed","line":"609","kind":"property"},{"ref":{"refId":"dart.core/List","name":"List"},"isFinal":true,"name":"_raw","isPrivate":true,"id":"_raw","line":"563","kind":"variable"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"isFinal":true,"name":"_reader","isPrivate":true,"id":"_reader","line":"564","kind":"variable"},{"name":"_LazyList","id":"_LazyList2()","children":[{"initializedField":{"refId":"serialization/_LazyList/_raw","name":"_raw"},"ref":{"refId":"dart.core/List","name":"List"},"name":"_raw","isPrivate":true,"id":"_raw","kind":"param"},{"initializedField":{"refId":"serialization/_LazyList/_reader","name":"_reader"},"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"_reader","isPrivate":true,"id":"_reader","kind":"param"}],"line":"561","kind":"constructor"}],"line":"560","kind":"class"},{"interfaces":[{"refId":"dart.core/Map","name":"Map"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis provides an implementation of Map that wraps a list which may\ncontain references to (potentially) non-inflated objects. If these\nare accessed it will inflate them. This allows us to pass something that\nlooks like it's just a list of objects to a [CustomRule] without needing\nto inflate all the references in advance.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"_LazyMap","isPrivate":true,"id":"_LazyMap","children":[{"isOperator":true,"name":"[]","id":"[]1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"528","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"containsKey","id":"containsKey1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"534","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"containsValue","id":"containsValue1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"539","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"forEach","id":"forEach1()","children":[{"name":"f","id":"f","kind":"param"}],"line":"541","kind":"method"},{"name":"_throw","isPrivate":true,"id":"_throw0()","line":"544","kind":"method"},{"isOperator":true,"name":"[]=","id":"[]=2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"547","kind":"method"},{"name":"putIfAbsent","id":"putIfAbsent2()","children":[{"name":"x","id":"x","kind":"param"},{"name":"y","id":"y","kind":"param"}],"line":"548","kind":"method"},{"name":"remove","id":"remove1()","children":[{"name":"x","id":"x","kind":"param"}],"line":"549","kind":"method"},{"name":"clear","id":"clear0()","line":"550","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"length","id":"length","line":"530","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"isEmpty","id":"isEmpty","line":"531","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"isNotEmpty","id":"isNotEmpty","line":"532","kind":"property"},{"ref":{"refId":"dart.core/Iterable","name":"Iterable"},"name":"keys","id":"keys","line":"533","kind":"property"},{"name":"_inflated","isPrivate":true,"id":"_inflated","line":"538","kind":"property"},{"ref":{"refId":"dart.core/Iterable","name":"Iterable"},"name":"values","id":"values","line":"540","kind":"property"},{"ref":{"refId":"dart.core/Map","name":"Map"},"isFinal":true,"name":"_raw","isPrivate":true,"id":"_raw","line":"524","kind":"variable"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"isFinal":true,"name":"_reader","isPrivate":true,"id":"_reader","line":"525","kind":"variable"},{"name":"_LazyMap","id":"_LazyMap2()","children":[{"initializedField":{"refId":"serialization/_LazyMap/_raw","name":"_raw"},"ref":{"refId":"dart.core/Map","name":"Map"},"name":"_raw","isPrivate":true,"id":"_raw","kind":"param"},{"initializedField":{"refId":"serialization/_LazyMap/_reader","name":"_reader"},"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"_reader","isPrivate":true,"id":"_reader","kind":"param"}],"line":"522","kind":"constructor"}],"line":"521","kind":"class"},{"superclass":{"refId":"serialization/CustomRule","name":"CustomRule"},"comment":"A hard-coded rule for DateTime. ","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"DateTimeRule","id":"DateTimeRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"appliesTo","id":"appliesTo2()","children":[{"name":"instance","id":"instance","kind":"param"},{"name":"_","isPrivate":true,"id":"_","kind":"param"}],"line":"497","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"name":"getState","id":"getState1()","children":[{"ref":{"refId":"dart.core/DateTime","name":"DateTime"},"name":"date","id":"date","kind":"param"}],"line":"498","kind":"method"},{"name":"create","id":"create1()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"}],"line":"499","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"setState","id":"setState2()","children":[{"name":"date","id":"date","kind":"param"},{"name":"state","id":"state","kind":"param"}],"line":"501","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"dataLength","id":"dataLength","line":"503","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"504","kind":"property"}],"line":"496","kind":"class"},{"superclass":{"refId":"serialization/CustomRule","name":"CustomRule"},"comment":"A hard-coded rule for serializing Symbols. ","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"SymbolRule","id":"SymbolRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"appliesTo","id":"appliesTo2()","children":[{"name":"instance","id":"instance","kind":"param"},{"name":"_","isPrivate":true,"id":"_","kind":"param"}],"line":"487","kind":"method"},{"name":"getState","id":"getState1()","children":[{"name":"instance","id":"instance","kind":"param"}],"line":"488","kind":"method"},{"name":"create","id":"create1()","children":[{"name":"state","id":"state","kind":"param"}],"line":"489","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"setState","id":"setState2()","children":[{"name":"symbol","id":"symbol","kind":"param"},{"name":"state","id":"state","kind":"param"}],"line":"490","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"name":"dataLength","id":"dataLength","line":"491","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"492","kind":"property"}],"line":"486","kind":"class"},{"isAbstract":true,"superclass":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"\nThis provides an abstract superclass for writing your own rules specific to\na class. It makes some assumptions about behaviour, and so can have a\nsimpler set of methods that need to be implemented in order to subclass it.\n\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"CustomRule","id":"CustomRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","name":"appliesTo","id":"appliesTo2()","children":[{"name":"instance","id":"instance","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"440","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"comment":"\nSubclasses should implement this to return a list of the important fields\nin the object. The order of the fields doesn't matter, except that the\ncreate and setState methods need to know how to use it.\n","name":"getState","id":"getState1()","children":[{"name":"instance","id":"instance","kind":"param"}],"line":"447","kind":"method"},{"comment":"\nGiven a [List] of the object's [state], re-create the object. This should\ndo the minimum needed to create the object, just calling the constructor.\nSetting the remaining state of the object should be done in the [setState]\nmethod, which will be called only once all the objects are created, so\nit won't cause problems with cycles.\n","name":"create","id":"create1()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"}],"line":"456","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nSet any state in [object] which wasn't set in the constructor. Between\nthis method and [create] all of the information in [state] should be set\nin the new object.\n","name":"setState","id":"setState2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"}],"line":"463","kind":"method"},{"name":"extractState","id":"extractState3()","children":[{"name":"instance","id":"instance","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"465","kind":"method"},{"name":"inflateEssential","id":"inflateEssential2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"473","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"name":"state","id":"state","kind":"param"},{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"475","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"482","kind":"property"}],"line":"430","kind":"class"},{"superclass":{"refId":"serialization/NamedObjectRule","name":"NamedObjectRule"},"comment":"\nThis rule handles the special case of Mirrors. It stores the mirror by its\nqualifiedName and attempts to look it up in both the namedObjects\ncollection, or if it's not found there, by looking it up in the mirror\nsystem. When reading, the user is responsible for supplying the appropriate\nvalues in [Serialization.namedObjects] or in the [externals] paramter to\n[Serialization.read].\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"MirrorRule","id":"MirrorRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"392","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"nameFor","id":"nameFor2()","children":[{"ref":{"refId":"dart.mirrors/DeclarationMirror","name":"DeclarationMirror"},"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"394","kind":"method"},{"name":"inflateEssential","id":"inflateEssential2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"397","kind":"method"}],"line":"391","kind":"class"},{"superclass":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"\nThis rule handles things we can't pass directly, but only by reference.\nIf objects are listed in the namedObjects in the writer or serialization,\nit will save the name rather than saving the state.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"NamedObjectRule","id":"NamedObjectRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if this rule applies to the object. Checked by looking up\nin the namedObjects collection.\n","name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"351","kind":"method"},{"comment":"Extract the state of the named objects as just the object itself. ","name":"extractState","id":"extractState3()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"356","kind":"method"},{"comment":"When we flatten the state we save it as the name. ","name":"flatten","id":"flatten2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"368","kind":"method"},{"comment":"Look up the named object and return it. ","name":"inflateEssential","id":"inflateEssential2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"373","kind":"method"},{"comment":"Set any non-essential state on the object. For this rule, a no-op. ","name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"name":"state","id":"state","kind":"param"},{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"377","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"comment":"Return the name for this object in the Writer. ","name":"nameFor","id":"nameFor2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"380","kind":"method"}],"line":"346","kind":"class"},{"superclass":{"refId":"serialization/CustomRule","name":"CustomRule"},"comment":"\nThis is a rule where the extraction and creation are hard-coded as\nclosures. The result is expected to be a map indexed by field name.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"ClosureRule","id":"ClosureRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"329","kind":"method"},{"name":"getState","id":"getState1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"331","kind":"method"},{"name":"create","id":"create1()","children":[{"name":"state","id":"state","kind":"param"}],"line":"333","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"setState","id":"setState2()","children":[{"name":"object","id":"object","kind":"param"},{"name":"state","id":"state","kind":"param"}],"line":"335","kind":"method"},{"ref":{"refId":"dart.core/Type","name":"Type"},"isFinal":true,"comment":"The runtimeType of objects that this rule applies to. Used in appliesTo.","name":"type","id":"type","line":"310","kind":"variable"},{"ref":{"refId":"serialization/ConstructType","name":"ConstructType"},"comment":"The function for constructing new objects when reading. ","name":"construct","id":"construct","line":"313","kind":"variable"},{"ref":{"refId":"serialization/GetStateType","name":"GetStateType"},"comment":"The function for returning an object's state as a Map. ","name":"getStateFunction","id":"getStateFunction","line":"316","kind":"variable"},{"ref":{"refId":"serialization/NonEssentialStateType","name":"NonEssentialStateType"},"comment":"The function for setting an object's state from a Map. ","name":"setNonEssentialState","id":"setNonEssentialState","line":"319","kind":"variable"},{"comment":"\nCreate a ClosureToMapRule for the given [type] which gets an object's\nstate by calling [getState], creates a new object by calling [construct]\nand sets the new object's state by calling [setNonEssentialState].\n","name":"ClosureRule","id":"ClosureRule4()","children":[{"initializedField":{"refId":"serialization/ClosureRule/type","name":"type"},"ref":{"refId":"dart.core/Type","name":"Type"},"name":"type","id":"type","kind":"param"},{"initializedField":{"refId":"serialization/ClosureRule/getStateFunction","name":"getStateFunction"},"ref":{"refId":"serialization/GetStateType","name":"GetStateType"},"name":"getStateFunction","id":"getStateFunction","kind":"param"},{"initializedField":{"refId":"serialization/ClosureRule/construct","name":"construct"},"ref":{"refId":"serialization/ConstructType","name":"ConstructType"},"name":"construct","id":"construct","kind":"param"},{"initializedField":{"refId":"serialization/ClosureRule/setNonEssentialState","name":"setNonEssentialState"},"ref":{"refId":"serialization/NonEssentialStateType","name":"NonEssentialStateType"},"name":"setNonEssentialState","id":"setNonEssentialState","line":"327","kind":"param"}],"line":"326","kind":"constructor"}],"line":"307","kind":"class"},{"returnType":{"refId":"void","name":"void"},"comment":"Typedef for the state-setting closure used in ClosureToMapRule. ","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"NonEssentialStateType","id":"NonEssentialStateType","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"m","id":"m","kind":"param"}],"line":"301","kind":"typedef"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"Typedef for the state-getting closure used in ClosureToMapRule. ","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"GetStateType","id":"GetStateType","children":[{"name":"object","id":"object","kind":"param"}],"line":"298","kind":"typedef"},{"comment":"Typedef for the object construction closure used in ClosureRule. ","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"ConstructType","id":"ConstructType","children":[{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"m","id":"m","kind":"param"}],"line":"295","kind":"typedef"},{"superclass":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"\nThis rule handles primitive types, defined as those that we can normally\nrepresent directly in the output format. We hard-code that to mean\nnum, String, and bool.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"PrimitiveRule","id":"PrimitiveRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"275","kind":"method"},{"name":"extractState","id":"extractState3()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"276","kind":"method"},{"name":"flatten","id":"flatten2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"277","kind":"method"},{"name":"inflateEssential","id":"inflateEssential2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"278","kind":"method"},{"name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"name":"object","id":"object","kind":"param"},{"name":"_","isPrivate":true,"id":"_","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"279","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIndicate whether we should save pointers to this object as references\nor store the object directly. For primitives this depends on the format,\nso we delegate to the writer.\n","name":"shouldUseReferenceFor","id":"shouldUseReferenceFor2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"288","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"storesStateAsPrimitives","id":"storesStateAsPrimitives","line":"281","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"291","kind":"property"}],"line":"274","kind":"class"},{"superclass":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"\nThis rule handles things that implement Map. It will recreate them as\nwhatever the default implemenation of Map is on the target platform. If a\nmap has string keys it will attempt to retain it as a map for JSON formats,\notherwise it will store it as a list of references to keys and values.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"MapRule","id":"MapRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"199","kind":"method"},{"name":"extractState","id":"extractState3()","children":[{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"map","id":"map","kind":"param"},{"name":"f","id":"f","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"203","kind":"method"},{"comment":"\nChange the keys and values of [state] into references in [writer].\nIf [state] is a map whose keys are all strings then we leave the keys\nas is so that JSON formats will be more readable. If the keys are\narbitrary then we need to turn them into references and replace the\nstate with a new Map whose keys are the references.\n","name":"flatten","id":"flatten2()","children":[{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"220","kind":"method"},{"name":"inflateEssential","id":"inflateEssential2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"236","kind":"method"},{"name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"newMap","id":"newMap","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"240","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"inflateNonEssentialFromList","id":"inflateNonEssentialFromList3()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"},{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"newMap","id":"newMap","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"248","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"inflateNonEssentialFromMap","id":"inflateNonEssentialFromMap3()","children":[{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"state","id":"state","kind":"param"},{"ref":{"refId":"dart.core/Map","name":"Map"},"name":"newMap","id":"newMap","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"260","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"storesStateAsMaps","id":"storesStateAsMaps","line":"201","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"266","kind":"property"}],"line":"197","kind":"class"},{"superclass":{"refId":"serialization/ListRule","name":"ListRule"},"comment":"\nThis is a subclass of ListRule where all of the list's contents are\nconsidered essential state. This is needed if an object X contains a List L,\nbut it expects L's contents to be fixed when X's constructor is called.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"ListRuleEssential","id":"ListRuleEssential","children":[{"comment":"Create the new List and also inflate all of its contents. ","name":"inflateEssential","id":"inflateEssential2()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"179","kind":"method"},{"comment":"Does nothing, because all the work has been done in inflateEssential. ","name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"name":"state","id":"state","kind":"param"},{"name":"newList","id":"newList","kind":"param"},{"name":"reader","id":"reader","kind":"param"}],"line":"186","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"mustBePrimary","id":"mustBePrimary","line":"188","kind":"property"}],"line":"176","kind":"class"},{"superclass":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"\nThis rule handles things that implement List. It will recreate them as\nwhatever the default implemenation of List is on the target platform.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"ListRule","id":"ListRule","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"141","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"name":"extractState","id":"extractState3()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"list","id":"list","kind":"param"},{"name":"f","id":"f","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"145","kind":"method"},{"name":"inflateEssential","id":"inflateEssential2()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"154","kind":"method"},{"name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"newList","id":"newList","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"158","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"populateContents","id":"populateContents3()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"state","id":"state","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"newList","id":"newList","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"r","id":"r","kind":"param"}],"line":"162","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"storesStateAsLists","id":"storesStateAsLists","line":"143","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"168","kind":"property"}],"line":"139","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThe abstract superclass for serialization rules.\n","uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"SerializationRule","id":"SerializationRule","children":[{"returnType":{"refId":"void","name":"void"},"isSetter":true,"comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","name":"number=","id":"number=1()","children":[{"ref":{"refId":"dart.core/int","name":"int"},"name":"value","id":"value","kind":"param"}],"line":"30","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if this rule applies to this object, in the context\nwhere we're writing it, false otherwise.\n","name":"appliesTo","id":"appliesTo2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"40","kind":"method"},{"comment":"\nThis extracts the state from the object, calling [f] for each value\nas it is extracted, and returning an object representing the whole\nstate at the end. The state that results will still have direct\npointers to objects, rather than references.\n","name":"extractState","id":"extractState3()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"name":"f","id":"f","children":[{"returnType":{"refId":"void","name":"void"},"uri":"sdk/lib/core/function.dart","name":"Function","id":"Function","children":[{"uri":"pkg/serialization/lib/src/serialization_rule.dart","name":"value","id":"value","line":"48","kind":"param"}],"line":"13","kind":"functiontype"}],"kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"}],"line":"48","kind":"method"},{"comment":"\nGiven the variables representing the state of an object, flatten it\nby turning object pointers into Reference objects where needed. This\ndestructively modifies the state object.\n\nThis has a default implementation which assumes that object is indexable,\nso either conforms to Map or List. Subclasses may override to do something\ndifferent, including returning a new state object to be used in place\nof the original.\n","name":"flatten","id":"flatten2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"73","kind":"method"},{"comment":"\nCreate the new object corresponding to [state] using the rules\nfrom [reader]. This may involve recursively inflating \"essential\"\nreferences in the state, which are those that are required for the\nobject's constructor. It is up to the rule what state is considered\nessential.\n","name":"inflateEssential","id":"inflateEssential2()","children":[{"name":"state","id":"state","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"103","kind":"method"},{"comment":"\nThe [object] has already been created. Set any of its non-essential\nvariables from the representation in [state]. Where there are references\nto other objects they are resolved in the context of [reader].\n","name":"inflateNonEssential","id":"inflateNonEssential3()","children":[{"name":"state","id":"state","kind":"param"},{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Reader","name":"Reader"},"name":"reader","id":"reader","kind":"param"}],"line":"110","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIf we have [object] as part of our state, should we represent that\ndirectly, or should we make a reference for it. By default, true.\nThis may also delegate to [writer].\n","name":"shouldUseReferenceFor","id":"shouldUseReferenceFor2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"117","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","name":"number","id":"number","line":"24","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nAllows rules to tell us how they expect to store their state. If this\nisn't specified we can also just look at the data to tell.\n","name":"storesStateAsLists","id":"storesStateAsLists","line":"54","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"storesStateAsMaps","id":"storesStateAsMaps","line":"55","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"storesStateAsPrimitives","id":"storesStateAsPrimitives","line":"56","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"Return true if this rule should only be applied when we are the first\nrule found that applies to this object. This may or may not be a hack\nthat will disappear once we have better support for multiple rules.\nWe want to have multiple different rules that apply to the same object. We\nalso want to have multiple different rules that might exclusively apply\nto the same object. So, we want either ListRule or ListRuleEssential, and\nonly one of them can be there. But on the other hand, we may want both\nListRule and BasicRule. So we identify the kinds of rules that can share.\nIf mustBePrimary returns true, then this rule will only be chosen if no\nother rule has been found yet. This means that the ordering of rules in\nthe serialization is significant, which is unpleasant, but we'll have\nto see how bad it is.\n","name":"mustBePrimary","id":"mustBePrimary","line":"94","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if the data this rule returns is variable length, so a\nlength needs to be written for it if the format requires that. Return\nfalse if the results are always the same length.\n","name":"hasVariableLengthEntries","id":"hasVariableLengthEntries","line":"124","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nIf the data is fixed length, return it here. The format may or may not\nmake use of this, depending on whether it already has enough information\nto determine the length on its own. If [hasVariableLengthEntries] is true\nthis is ignored.\n","name":"dataLength","id":"dataLength","line":"132","kind":"property"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nRules belong uniquely to a particular Serialization instance, and can\nbe identified within it by number.\n","name":"_number","isPrivate":true,"id":"_number","line":"18","kind":"variable"}],"line":"13","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis is used during tracing to indicate that an object should be processed\nusing a particular rule, rather than the one that might ordinarily be\nfound for it. This normally only makes sense if the object is uniquely\nreferenced, and is a more or less internal collection. See ListRuleEssential\nfor an example. It knows how to return its object and how to filter.\n","uri":"pkg/serialization/lib/src/reader_writer.dart","name":"DesignatedRuleForObject","id":"DesignatedRuleForObject","children":[{"returnType":{"refId":"dart.core/List","name":"List"},"name":"possibleRules","id":"possibleRules1()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"rules","id":"rules","kind":"param"}],"line":"622","kind":"method"},{"ref":{"refId":"dart.core/Function","name":"Function"},"isFinal":true,"name":"rulePredicate","id":"rulePredicate","line":"617","kind":"variable"},{"isFinal":true,"name":"target","id":"target","line":"618","kind":"variable"},{"name":"DesignatedRuleForObject","id":"DesignatedRuleForObject2()","children":[{"initializedField":{"refId":"serialization/DesignatedRuleForObject/target","name":"target"},"name":"target","id":"target","kind":"param"},{"initializedField":{"refId":"serialization/DesignatedRuleForObject/rulePredicate","name":"rulePredicate"},"ref":{"refId":"dart.core/Function","name":"Function"},"name":"rulePredicate","id":"rulePredicate","kind":"param"}],"line":"620","kind":"constructor"}],"line":"616","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAny pointers to objects that can't be represented directly in the\nserialization format has to be stored as a reference. A reference encodes\nthe rule number of the rule that saved it in the Serialization that was used\nfor writing, and the object number within that rule.\n","uri":"pkg/serialization/lib/src/reader_writer.dart","name":"Reference","id":"Reference","children":[{"comment":"\nReturn the thing this reference points to. Assumes that we have a valid\nparent and that it is a Reader, as inflating is not meaningful when\nwriting.\n","name":"inflated","id":"inflated0()","line":"585","kind":"method"},{"returnType":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"},{"refId":"dart.core/int","name":"int"}],"name":"Map"},"comment":"\nConvert the reference to a map in JSON format. This is specific to the\ncustom JSON format we define, and must be consistent with the\n[Reader.asReference] method.\n","name":"toJson","id":"toJson0()","line":"594","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Write our information to [list]. Useful in writing to flat formats.","name":"writeToList","id":"writeToList1()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"list","id":"list","kind":"param"}],"line":"601","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"606","kind":"method"},{"ref":{"refId":"serialization/ReaderOrWriter","name":"ReaderOrWriter"},"isFinal":true,"comment":"The [Reader] or [Writer] that owns this reference. ","name":"parent","id":"parent","line":"565","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isFinal":true,"comment":"The position of the rule that controls this reference in [parent]. ","name":"ruleNumber","id":"ruleNumber","line":"567","kind":"variable"},{"ref":{"refId":"dart.core/int","name":"int"},"isFinal":true,"comment":"The index of the referred-to object in the storage of [parent] ","name":"objectNumber","id":"objectNumber","line":"569","kind":"variable"},{"name":"Reference","id":"Reference3()","children":[{"initializedField":{"refId":"serialization/Reference/parent","name":"parent"},"ref":{"refId":"serialization/ReaderOrWriter","name":"ReaderOrWriter"},"name":"parent","id":"parent","kind":"param"},{"initializedField":{"refId":"serialization/Reference/ruleNumber","name":"ruleNumber"},"ref":{"refId":"dart.core/int","name":"int"},"name":"ruleNumber","id":"ruleNumber","kind":"param"},{"initializedField":{"refId":"serialization/Reference/objectNumber","name":"objectNumber"},"ref":{"refId":"dart.core/int","name":"int"},"name":"objectNumber","id":"objectNumber","kind":"param"}],"line":"571","kind":"constructor"}],"line":"563","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis represents the transitive closure of the referenced objects to be\nused for serialization. It works closely in conjunction with the Writer,\nand is kept as a separate object primarily for the possibility of wanting\nto plug in different sorts of tracing rules.\n","uri":"pkg/serialization/lib/src/reader_writer.dart","name":"Trace","id":"Trace","children":[{"returnType":{"refId":"void","name":"void"},"name":"addRoot","id":"addRoot1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"518","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"A convenience method to add a single root and trace it in one step. ","name":"trace","id":"trace1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"523","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nProcess all of the objects reachable from our roots via state that the\nserialization rules access.\n","name":"traceAll","id":"traceAll0()","line":"532","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nHas this object been seen yet? We test for this by checking if the\nwriter has a reference for it. See comment for _hasIndexFor.\n","name":"hasProcessed","id":"hasProcessed1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"544","kind":"method"},{"comment":"Note that we've seen [value], and add it to the queue to be processed. ","name":"note","id":"note1()","children":[{"name":"value","id":"value","kind":"param"}],"line":"549","kind":"method"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"isFinal":true,"name":"writer","id":"writer","line":"505","kind":"variable"},{"ref":{"refId":"dart.collection/Queue","name":"Queue"},"isFinal":true,"comment":"\nThis class works by doing a breadth-first traversal of the objects,\nwith the traversal order maintained in [queue].\n","name":"queue","id":"queue","line":"511","kind":"variable"},{"ref":{"refId":"dart.core/List","name":"List"},"isFinal":true,"comment":"The root objects from which we will be tracing. ","name":"roots","id":"roots","line":"514","kind":"variable"},{"name":"Trace","id":"Trace1()","children":[{"initializedField":{"refId":"serialization/Trace/writer","name":"writer"},"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"writer","id":"writer","kind":"param"}],"line":"516","kind":"constructor"}],"line":"501","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis serves as a marker to indicate a object that is in the process of\nbeing de-serialized. So if we look for an object slot and find one of these,\nwe know we've hit a cycle.\n","uri":"pkg/serialization/lib/src/reader_writer.dart","name":"_Sentinel","isPrivate":true,"id":"_Sentinel","children":[{"name":"_Sentinel","id":"_Sentinel0()","line":"492","kind":"constructor"}],"line":"491","kind":"class"},{"interfaces":[{"refId":"serialization/ReaderOrWriter","name":"ReaderOrWriter"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThe main class responsible for reading. It holds\nonto the necessary state and to the objects that have been inflated.\n","uri":"pkg/serialization/lib/src/reader_writer.dart","name":"Reader","id":"Reader","children":[{"comment":"\nLook up the reference to an external object. This can be held either in\nthe reader-specific list of externals or in the serializer's\n","name":"objectNamed","id":"objectNamed2()","children":[{"name":"key","id":"key","kind":"param"},{"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"name":"ifAbsent","id":"ifAbsent","kind":"param"}],"line":"320","kind":"method"},{"returnType":{"refId":"void","name":"void"},"name":"keyNotFound","id":"keyNotFound1()","children":[{"name":"key","id":"key","kind":"param"}],"line":"329","kind":"method"},{"returnType":{"refId":"void","name":"void"},"isSetter":true,"comment":"\nInternal use only, for testing purposes. Set the data for this reader\nto a List of Lists whose size must match the number of rules.\n","name":"data=","id":"data=1()","children":[{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List","name":"List"}],"name":"List"},"name":"newData","id":"newData","kind":"param"}],"line":"345","kind":"method"},{"comment":"\nThis is the primary method for a [Reader]. It takes the input data,\ndecodes it according to [format] and returns the root object.\n","name":"read","id":"read2()","children":[{"name":"rawInput","id":"rawInput","kind":"param"},{"ref":{"refId":"dart.core/Map","name":"Map"},"isOptional":true,"defaultValue":"const{}","name":"externals","id":"externals","kind":"param"}],"line":"354","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nIf the data we are reading from has rules written to it, read them back\nand set them as the rules we will use.\n","name":"readRules","id":"readRules1()","children":[{"name":"newRules","id":"newRules","kind":"param"}],"line":"366","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nInflate all of the objects for [rule]. Does the essential state for all\nobjects first, then the non-essential state. This avoids cycles in\nnon-essential state, because all the objects will have already been\ncreated.\n","name":"inflateForRule","id":"inflateForRule1()","children":[{"name":"rule","id":"rule","kind":"param"}],"line":"383","kind":"method"},{"comment":"\nCreate a new object, based on [rule] and [state], which will\nbe stored in [position] in the storage for [rule]. This will\nfollow references and recursively inflate them, leaving Sentinel objects\nto detect cycles.\n","name":"inflateOne","id":"inflateOne3()","children":[{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"},{"name":"position","id":"position","kind":"param"},{"name":"state","id":"state","kind":"param"}],"line":"399","kind":"method"},{"comment":"\nThe parameter [possibleReference] might be a reference. If it isn't, just\nreturn it. If it is, then inflate the target of the reference and return\nthe resulting object.\n","name":"inflateReference","id":"inflateReference1()","children":[{"name":"possibleReference","id":"possibleReference","kind":"param"}],"line":"420","kind":"method"},{"comment":"Return the object pointed to by [reference]. ","name":"resolveReference","id":"resolveReference1()","children":[{"name":"reference","id":"reference","kind":"param"}],"line":"433","kind":"method"},{"comment":"\nGiven [reference], return what we have stored as an object for it. Note\nthat, depending on the current state, this might be null or a Sentinel.\n","name":"_objectFor","isPrivate":true,"id":"_objectFor1()","children":[{"ref":{"refId":"serialization/Reference","name":"Reference"},"name":"reference","id":"reference","kind":"param"}],"line":"439","kind":"method"},{"comment":"Given [rule], return the storage for its objects. ","name":"allObjectsForRule","id":"allObjectsForRule1()","children":[{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"}],"line":"443","kind":"method"},{"comment":"Given [reference], return the the state we have stored for it. ","name":"_stateFor","isPrivate":true,"id":"_stateFor1()","children":[{"ref":{"refId":"serialization/Reference","name":"Reference"},"name":"reference","id":"reference","kind":"param"}],"line":"446","kind":"method"},{"returnType":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"Given a reference, return the rule it references. ","name":"ruleFor","id":"ruleFor1()","children":[{"ref":{"refId":"serialization/Reference","name":"Reference"},"name":"reference","id":"reference","kind":"param"}],"line":"450","kind":"method"},{"returnType":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"comment":"\nReturn the primitive rule we are using. This is an ugly mechanism to\nsupport the extra information to reconstruct objects in the\n[SimpleJsonFormat].\n","name":"_primitiveRule","isPrivate":true,"id":"_primitiveRule0()","line":"458","kind":"method"},{"comment":"\nGiven a possible reference [anObject], call either [ifReference] or\n[ifNotReference], depending if it's a reference or not. This is the\nprimary place that knows about the serialized representation of a\nreference.\n","name":"asReference","id":"asReference3()","children":[{"name":"anObject","id":"anObject","kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"defaultValue":"doNothing","name":"ifReference","id":"ifReference","kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/Function","name":"Function"},"isOptional":true,"defaultValue":"doNothing","name":"ifNotReference","id":"ifNotReference","line":"474","kind":"param"}],"line":"473","kind":"method"},{"comment":"Return the internal collection of object state and [Reference] objects. ","name":"states","id":"states","line":"285","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"serialization/SerializationRule","name":"SerializationRule"}],"name":"List"},"comment":"\nReturn the list of rules to be used when writing. These come from the\n[serialization].\n","name":"rules","id":"rules","line":"338","kind":"property"},{"ref":{"refId":"serialization/Serialization","name":"Serialization"},"comment":"\nThe serialization that specifies how we read. Note that in contrast\nto the Writer, this is not final. This is because we may be created\nwith an empty [Serialization] and then read the rules from the data,\nif [selfDescribing] is true.\n","name":"serialization","id":"serialization","line":"266","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nWhen we read objects, should we read a description of the rules if\npresent. This defaults to the corresponding value on the Serialization.\n","name":"selfDescribing","id":"selfDescribing","line":"272","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List","name":"List"}],"name":"List"},"comment":"\nThe state of objects that have been serialized is stored here.\nEach rule has a number, and rules keep track of the objects that they\nserialize, in order. So the state of any object can be found by indexing\nfrom the rule number and the object number within the rule.\nThe actual representation of the state is determined by the rule. Lists\nand Maps are common, but it is arbitrary. See [Writer.states].\n","name":"_data","isPrivate":true,"id":"_data","line":"282","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List","name":"List"}],"name":"List"},"comment":"\nThe resulting objects, indexed according to the same scheme as\n_data, where each rule has a number, and rules keep track of the objects\nthat they serialize, in order.\n","name":"objects","id":"objects","line":"292","kind":"variable"},{"ref":{"refId":"serialization/Format","name":"Format"},"isFinal":true,"name":"format","id":"format","line":"294","kind":"variable"},{"ref":{"refId":"dart.core/Map","name":"Map"},"comment":"\nWhen we read, we may need to look up objects by name in order to link to\nthem. This is particularly true if we have references to classes,\nfunctions, mirrors, or other non-portable entities. The map in which we\nlook things up can be provided as an argument to read, but we can also\nprovide a map here, and objects will be looked up in both places.\n","name":"namedObjects","id":"namedObjects","line":"314","kind":"variable"},{"comment":"\nCreates a new [Reader] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state related to\na particular read or write operation, so the same one can be used\nfor multiple different Writers/Readers.\n","name":"Reader","id":"Reader2()","children":[{"initializedField":{"refId":"serialization/Reader/serialization","name":"serialization"},"ref":{"refId":"serialization/Serialization","name":"Serialization"},"name":"serialization","id":"serialization","kind":"param"},{"ref":{"refId":"serialization/Format","name":"Format"},"isOptional":true,"name":"newFormat","id":"newFormat","kind":"param"}],"line":"302","kind":"constructor"}],"line":"258","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn abstract class for Reader and Writer, which primarily exists so we can\ntype things that will refer to one or the other, depending on which\noperation we're doing.\n","uri":"pkg/serialization/lib/src/reader_writer.dart","name":"ReaderOrWriter","id":"ReaderOrWriter","children":[{"comment":"\nReturn the object, or state, that ref points to, depending on which\nwe're generating.\n","name":"resolveReference","id":"resolveReference1()","children":[{"ref":{"refId":"serialization/Reference","name":"Reference"},"name":"ref","id":"ref","kind":"param"}],"line":"251","kind":"method"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"serialization/SerializationRule","name":"SerializationRule"}],"name":"List"},"comment":"Return the list of serialization rules we are using.","name":"rules","id":"rules","line":"242","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List","name":"List"}],"name":"List"},"comment":"Return the internal collection of object state and [Reference] objects. ","name":"states","id":"states","line":"245","kind":"property"}],"line":"240","kind":"class"},{"interfaces":[{"refId":"serialization/ReaderOrWriter","name":"ReaderOrWriter"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis writes out the state of the objects to an external format. It holds\nall of the intermediate state needed. The primary API for it is the\n[write] method.\n","uri":"pkg/serialization/lib/src/reader_writer.dart","name":"Writer","id":"Writer","children":[{"comment":"\nThis is the main API for a [Writer]. It writes the objects and returns\nthe serialized representation, as determined by [format].\n","name":"write","id":"write1()","children":[{"name":"anObject","id":"anObject","kind":"param"}],"line":"74","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nGiven that we have fully populated the list of [states], and more\nimportantly, the list of [references], go through each state and turn\nanything that requires a [Reference] into one. Since only the rules\nknow the representation they use for state, delegate to them.\n","name":"_flatten","isPrivate":true,"id":"_flatten0()","line":"87","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nAs the [trace] processes each object, it will call this method on us.\nWe find the rules for this object, and record the state of the object\nas determined by each rule.\n","name":"_process","isPrivate":true,"id":"_process2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Trace","name":"Trace"},"name":"trace","id":"trace","kind":"param"}],"line":"107","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nRecord the state of [object] as determined by [rule] and keep\ntrack of it. Generate a [Reference] for this object if required.\nWhen it's required is up to the particular rule, but generally everything\ngets a reference except a primitive.\nNote that at this point the states are just the same as the fields of the\nobject, and haven't been flattened.\n","name":"_record","isPrivate":true,"id":"_record2()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"}],"line":"122","kind":"method"},{"comment":"\nReturns a serialized version of the [SerializationRule]s used to write\nthe data, if [selfDescribing] is true, otherwise returns null.\n","name":"serializedRules","id":"serializedRules0()","line":"143","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Record a [state] entry for a particular rule. ","name":"_addStateForRule","isPrivate":true,"id":"_addStateForRule2()","children":[{"name":"eachRule","id":"eachRule","kind":"param"},{"name":"state","id":"state","kind":"param"}],"line":"152","kind":"method"},{"returnType":{"refId":"dart.core/int","name":"int"},"comment":"Find what the object number for the thing we're about to add will be.","name":"_nextObjectNumberFor","isPrivate":true,"id":"_nextObjectNumberFor1()","children":[{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"}],"line":"158","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nWe store the states in a List, indexed by rule number. But rules can be\ndynamically added, so we may have to grow the list.\n","name":"_growStates","isPrivate":true,"id":"_growStates1()","children":[{"name":"eachRule","id":"eachRule","kind":"param"}],"line":"167","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if we have an object number for this object. This is used to\ntell if we have processed the object or not. This relies on checking if we\nhave a reference or not. That saves some space by not having to keep track\nof simple objects, but means that if someone refers to the identical string\nfrom several places, we will process it several times, and store it\nseveral times. That seems an acceptable tradeoff, and in cases where it\nisn't, it's possible to apply a rule for String, or even for Strings larger\nthan x, which gives them references.\n","name":"_hasIndexFor","isPrivate":true,"id":"_hasIndexFor1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"181","kind":"method"},{"returnType":{"refId":"dart.core/int","name":"int"},"comment":"\nGiven an object, find what number it has. The number is valid only in\nthe context of a particular rule, and if the rule has more than one,\nthis will return the one for the primary rule, defined as the one that\nis listed in its canonical reference.\n","name":"_objectNumberFor","isPrivate":true,"id":"_objectNumberFor1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"191","kind":"method"},{"returnType":{"refId":"dart.core/List","name":"List"},"comment":"\nReturn a list of [Reference] objects pointing to our roots. This will be\nstored in the output under \"roots\" in the default format.\n","name":"_rootReferences","isPrivate":true,"id":"_rootReferences0()","line":"200","kind":"method"},{"comment":"\nGiven an object, return a reference for it if one exists. If there's\nno reference, return the object itself. Once we have finished the tracing\nstep, all objects that should have a reference (roughly speaking,\nnon-primitives) can be relied on to have a reference.\n","name":"_referenceFor","isPrivate":true,"id":"_referenceFor1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"208","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"\nReturn true if the [Serialization.namedObjects] collection has a\nreference to [object].\n","name":"hasNameFor","id":"hasNameFor1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"220","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"comment":"\nReturn the name we have for this object in the [Serialization.namedObjects]\ncollection.\n","name":"nameFor","id":"nameFor1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"226","kind":"method"},{"name":"stateForReference","id":"stateForReference1()","children":[{"ref":{"refId":"serialization/Reference","name":"Reference"},"name":"r","id":"r","kind":"param"}],"line":"229","kind":"method"},{"comment":"Return the state pointed to by [reference]. ","name":"resolveReference","id":"resolveReference1()","children":[{"name":"reference","id":"reference","kind":"param"}],"line":"232","kind":"method"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"serialization/SerializationRule","name":"SerializationRule"}],"name":"List"},"comment":"Return the list of rules we use. ","name":"rules","id":"rules","line":"56","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nShould we store primitive objects directly or create references for them.\nThat depends on which format we're using, so a flat format will want\nreferences, but the Map format can store them directly.\n","name":"shouldUseReferencesForPrimitives","id":"shouldUseReferencesForPrimitives","line":"136","kind":"property"},{"ref":{"refId":"serialization/Serialization","name":"Serialization"},"isFinal":true,"comment":"\nThe [serialization] holds onto the rules that define how objects\nare serialized.\n","name":"serialization","id":"serialization","line":"21","kind":"variable"},{"ref":{"refId":"serialization/Trace","name":"Trace"},"comment":"The [trace] object keeps track of the objects to be visited while finding\nthe full set of objects to be written.","name":"trace","id":"trace","line":"25","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nWhen we write out objects, should we also write out a description\nof the rules for the serialization. This defaults to the corresponding\nvalue on the Serialization.\n","name":"selfDescribing","id":"selfDescribing","line":"32","kind":"variable"},{"ref":{"refId":"serialization/Format","name":"Format"},"isFinal":true,"name":"format","id":"format","line":"34","kind":"variable"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"serialization/Reference","name":"Reference"}],"name":"Map"},"isFinal":true,"comment":"\nObjects that cannot be represented in-place in the serialized form need\nto have references to them stored. The [Reference] objects are computed\nonce and stored here for each object. This provides some space-saving,\nbut also serves to record which objects we have already seen.\n","name":"references","id":"references","line":"42","kind":"variable"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/List","name":"List"}],"name":"List"},"isFinal":true,"comment":"\nThe state of objects that need to be serialized is stored here.\nEach rule has a number, and rules keep track of the objects that they\nserialize, in order. So the state of any object can be found by indexing\nfrom the rule number and the object number within the rule.\nThe actual representation of the state is determined by the rule. Lists\nand Maps are common, but it is arbitrary.\n","name":"states","id":"states","line":"53","kind":"variable"},{"comment":"\nCreates a new [Writer] that uses the rules from its parent\n[Serialization]. Serializations do not keep any state\nrelated to a particular read/write, so the same one can be used\nfor multiple different Readers/Writers.\n","name":"Writer","id":"Writer2()","children":[{"initializedField":{"refId":"serialization/Writer/serialization","name":"serialization"},"ref":{"refId":"serialization/Serialization","name":"Serialization"},"name":"serialization","id":"serialization","kind":"param"},{"ref":{"refId":"serialization/Format","name":"Format"},"isOptional":true,"name":"newFormat","id":"newFormat","kind":"param"}],"line":"64","kind":"constructor"}],"line":"16","kind":"class"},{"interfaces":[{"refId":"dart.core/Exception","name":"Exception"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"isThrowable":true,"comment":"\nAn exception class for errors during serialization.\n","name":"SerializationException","id":"SerializationException","children":[{"name":"toString","id":"toString0()","line":"504","kind":"method"},{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"name":"message","id":"message","line":"502","kind":"variable"},{"name":"SerializationException","id":"SerializationException1()","children":[{"initializedField":{"refId":"serialization/SerializationException/message","name":"message"},"ref":{"refId":"dart.core/String","name":"String"},"isOptional":true,"name":"message","id":"message","kind":"param"}],"line":"503","kind":"constructor"}],"line":"501","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nThis class defines a particular serialization scheme, in terms of\n[SerializationRule] instances, and supports reading and writing them.\nSee library comment for examples of usage.\n","name":"Serialization","id":"Serialization","children":[{"returnType":{"refId":"void","name":"void"},"isSetter":true,"comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","name":"selfDescribing=","id":"selfDescribing=1()","children":[{"ref":{"refId":"dart.core/bool","name":"bool"},"name":"value","id":"value","kind":"param"}],"line":"276","kind":"method"},{"returnType":{"refId":"serialization/BasicRule","name":"BasicRule"},"comment":"\nCreate a [BasicRule] rule for the type of\n[instanceOfType]. Optionally\nallows specifying a [constructor] name, the list of [constructorFields],\nand the list of [fields] not used in the constructor. Returns the new\nrule. Note that [BasicRule] uses reflection, and so will not work with the\ncurrent state of dartj2s. If you need to run there, consider using\n[CustomRule] instead.\n\nIf the optional parameters aren't specified, the default constructor will\nbe used, and the list of fields will be computed. Alternatively, you can\nomit [fields] and provide [excludeFields], which will then compute the\nlist of fields specifically excluding those listed.\n\nThe fields can be actual public fields, but can also be getter/setter\npairs or getters whose value is provided in the constructor. For the\n[constructorFields] they can also be arbitrary objects. Anything that is\nnot a String will be treated as a constant value to be used in any\nconstruction of these objects.\n\nIf the list of fields is computed, fields from the superclass will be\nincluded. However, each subclass needs its own rule, since the constructors\nare not inherited, and so may need to be specified separately for each\nsubclass.\n","name":"addRuleFor","id":"addRuleFor5()","children":[{"name":"instanceOfType","id":"instanceOfType","line":"322","kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/String","name":"String"},"isOptional":true,"name":"constructor","id":"constructor","line":"323","kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/List","name":"List"},"isOptional":true,"name":"constructorFields","id":"constructorFields","line":"324","kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"List"},"isOptional":true,"name":"fields","id":"fields","line":"325","kind":"param"},{"isNamed":true,"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"List"},"isOptional":true,"name":"excludeFields","id":"excludeFields","line":"326","kind":"param"}],"line":"321","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"Set up the default rules, for lists and primitives. ","name":"addDefaultRules","id":"addDefaultRules0()","line":"337","kind":"method"},{"returnType":{"refId":"void","name":"void"},"comment":"\nAdd a new SerializationRule [rule]. The addRuleFor method will probably\nhandle most simple cases, but for adding an arbitrary rule, including\na SerializationRule subclass which you have created, you can use this\nmethod.\n","name":"addRule","id":"addRule1()","children":[{"ref":{"refId":"serialization/SerializationRule","name":"SerializationRule"},"name":"rule","id":"rule","kind":"param"}],"line":"354","kind":"method"},{"comment":"\nThis writes out an object graph rooted at [object] and returns the result.\nThe [format] parameter determines the form of the result. The default\nformat returns a String in [json] format.\n","name":"write","id":"write2()","children":[{"ref":{"refId":"dart.core/Object","name":"Object"},"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Format","name":"Format"},"isOptional":true,"name":"format","id":"format","kind":"param"}],"line":"364","kind":"method"},{"returnType":{"refId":"serialization/Writer","name":"Writer"},"comment":"\nReturn a new [Writer] object for this serialization. This is useful if you\nwant to do something more complex with the writer than just returning\nthe final result.\n","name":"newWriter","id":"newWriter1()","children":[{"ref":{"refId":"serialization/Format","name":"Format"},"isOptional":true,"name":"format","id":"format","kind":"param"}],"line":"373","kind":"method"},{"comment":"\nRead the serialized data from [input] and return the root object\nfrom the result. The [input] can be of any type that the [Format]\nreads/writes, but normally will be a [List], [Map], or a simple type.\nIf there are objects that need to be resolved\nin the current context, they should be provided in [externals] as a\nMap from names to values. In particular, in the current implementation\nany class mirrors needed should be provided in [externals] using the\nclass name as a key. In addition to the [externals] map provided here,\nvalues will be looked up in the [namedObjects] map.\n","name":"read","id":"read2()","children":[{"name":"input","id":"input","kind":"param"},{"ref":{"refId":"dart.core/Map","name":"Map"},"isOptional":true,"defaultValue":"const{}","name":"externals","id":"externals","kind":"param"}],"line":"387","kind":"method"},{"returnType":{"refId":"serialization/Reader","name":"Reader"},"comment":"\nReturn a new [Reader] object for this serialization. This is useful if\nyou want to do something more complex with the reader than just returning\nthe final result.\n","name":"newReader","id":"newReader1()","children":[{"ref":{"refId":"serialization/Format","name":"Format"},"isOptional":true,"name":"format","id":"format","kind":"param"}],"line":"396","kind":"method"},{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"serialization/SerializationRule","name":"SerializationRule"}],"name":"Iterable"},"comment":"\nReturn the list of SerializationRule that apply to [object]. For\ninternal use, but public because it's used in testing.\n","name":"rulesFor","id":"rulesFor3()","children":[{"name":"object","id":"object","kind":"param"},{"ref":{"refId":"serialization/Writer","name":"Writer"},"name":"w","id":"w","kind":"param"},{"isNamed":true,"isOptional":true,"defaultValue":"true","name":"create","id":"create","kind":"param"}],"line":"402","kind":"method"},{"returnType":{"refId":"serialization/Serialization","name":"Serialization"},"comment":"\nCreate a Serialization for serializing SerializationRules. This is used\nto save the rules in a self-describing format along with the data.\nIf there are new rule classes created, they will need to be described\nhere.\n","name":"ruleSerialization","id":"ruleSerialization0()","line":"449","kind":"method"},{"returnType":{"refId":"dart.core/bool","name":"bool"},"comment":"Return true if our [namedObjects] collection has an entry for [object].","name":"_hasNameFor","isPrivate":true,"id":"_hasNameFor1()","children":[{"name":"object","id":"object","kind":"param"}],"line":"481","kind":"method"},{"comment":"\nReturn the name we have for [object] in our [namedObjects] collection or\nthe result of evaluating [ifAbsent] if there is no entry.\n","name":"_nameFor","isPrivate":true,"id":"_nameFor2()","children":[{"name":"object","id":"object","kind":"param"},{"isOptional":true,"name":"ifAbsent","id":"ifAbsent","kind":"param"}],"line":"490","kind":"method"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","name":"selfDescribing","id":"selfDescribing","line":"257","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"serialization/SerializationRule","name":"SerializationRule"}],"name":"List"},"isFinal":true,"comment":"\nThe serialization is controlled by the list of Serialization rules. These\nare most commonly added via [addRuleFor].\n","name":"rules","id":"rules","line":"230","kind":"variable"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/String","name":"String"}],"name":"Map"},"comment":"\nWhen reading, we may need to resolve references to existing objects in\nthe system. The right action may not be to create a new instance of\nsomething, but rather to find an existing instance and connect to it.\nFor example, if we have are serializing an Email message and it has a\nlink to the owning account, it may not be appropriate to try and serialize\nthe account. Instead we should just connect the de-serialized message\nobject to the account object that already exists there.\n","name":"namedObjects","id":"namedObjects","line":"241","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nWhen we write out data using this serialization, should we also write\nout a description of the rules. This is on by default unless using\nCustomRule subclasses, in which case it requires additional setup and\nis off by default.\n","name":"_selfDescribing","isPrivate":true,"id":"_selfDescribing","line":"249","kind":"variable"},{"comment":"\nCreates a new serialization with a default set of rules for primitives\nand lists.\n","name":"Serialization","id":"Serialization0()","line":"284","kind":"constructor"},{"comment":"\nCreates a new serialization with no default rules at all. The most common\nuse for this is if we are reading self-describing serialized data and\nwill populate the rules from that data.\n","name":"Serialization.blank","id":"Serialization.blank0()","line":"293","kind":"constructor"}],"line":"224","kind":"class"}],"line":"206","kind":"library"}