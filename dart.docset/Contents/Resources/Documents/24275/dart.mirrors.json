{"dependencies":[{"uri":"sdk/lib/core/core.dart","name":"dart:core","id":"dart.core","children":[{"comment":"\nEverything in Dart is an [Object].\n","uri":"sdk/lib/core/object.dart","name":"Object","id":"Object","children":[{"returnType":{"refId":"dart.core/bool","name":"bool"},"isOperator":true,"comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","name":"==","id":"==1()","children":[{"name":"other","id":"other","kind":"param"}],"line":"29","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"comment":"\nReturns a string representation of this object.\n","name":"toString","id":"toString0()","line":"48","kind":"method"},{"comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [Invocation].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","name":"noSuchMethod","id":"noSuchMethod1()","children":[{"ref":{"refId":"dart.core/Invocation","name":"Invocation"},"name":"invocation","id":"invocation","kind":"param"}],"line":"60","kind":"method"},{"ref":{"refId":"dart.core/int","name":"int"},"comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","name":"hashCode","id":"hashCode","line":"43","kind":"property"},{"ref":{"refId":"dart.core/Type","name":"Type"},"comment":"\nA representation of the runtime type of the object.\n","name":"runtimeType","id":"runtimeType","line":"65","kind":"property"},{"comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","name":"Object","id":"Object0()","line":"18","kind":"constructor"}],"line":"10","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"isThrowable":true,"comment":"\nA marker interface implemented by all core library exceptions.\n\nAn [Exception] is intended to convey information to the user about a failure,\nso that the error can be addressed programmatically. It is intended to be\ncaught, and it should contain useful data fields.\n\nCreating instances of [Exception] directly with [:new Exception(\"message\"):]\nis discouraged, and only included as a temporary measure during development,\nuntil the actual exceptions used by a library are done.\n","uri":"sdk/lib/core/exceptions.dart","name":"Exception","id":"Exception","children":[{"returnType":{"refId":"dart.core/Exception","name":"Exception"},"name":"Exception","id":"Exception1()","children":[{"isOptional":true,"name":"message","id":"message","kind":"param"}],"line":"21","kind":"constructor"}],"line":"20","kind":"class"}],"line":"5","kind":"library"}],"comment":"\nThe mirrors library provides basic reflection support for Dart.\nReflection here is limited to introspection and dynamic\nevaluation.\n\nIntrospection is that subset of reflection by which a running\nprogram can examine its own structure. For example, a function\nthat prints out the names of all the members of an arbitrary object.\n\nDynamic evaluation refers the ability to evaluate code that\nhas not been literally specified at compile time, such as calling a method\nwhose name is provided as an argument (because it is looked up\nin a database, or provided interactively by the user).\n\nHow to Interpret the Dartdoc specifications below\n\nAs a rule, the names of Dart declarations are represented using\ninstances of class [Symbol]. Whenever we speak of an object *s*\nof class [Symbol] denoting a name, we mean the string that\nwas used to construct *s*.\n\nWe will also frequently abuse notation and write\nDart pseudo-code such as [:o.x(a):], where we have defined\no and a to be objects; what is actually meant in these\ncases is [:o'.x(a'):] where *o'* and *a'* are Dart variables\nbound to *o* and *a* respectively. Furthermore, *o'* and *a'*\nare assumed to be fresh variables (meaning that they are\ndistinct from any other variables in the program).\n\nAn object is serializable across isolates if and only if it is an instance of\neither num, bool, String, a list of objects that are serializable\nacross isolates or a map whose keys and values are all serializable across\nisolates.\n","uri":"sdk/lib/mirrors/mirrors.dart","name":"dart:mirrors","id":"dart.mirrors","children":[{"returnType":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"comment":"\nReturns a [ClassMirror] for the class represented by a Dart\nType object.\n\nThis only works with objects local to the current isolate.\n","name":"reflectClass","id":"reflectClass1()","children":[{"ref":{"refId":"dart.core/Type","name":"Type"},"name":"key","id":"key","kind":"param"}],"line":"133","kind":"method"},{"returnType":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"comment":"\nReturns an [InstanceMirror] for some Dart language object.\n\nThis only works with objects local to the current isolate.\n","name":"reflect","id":"reflect1()","children":[{"ref":{"refId":"dart.core/Object","name":"Object"},"name":"reflectee","id":"reflectee","kind":"param"}],"line":"125","kind":"method"},{"returnType":{"refId":"dart.async/Future","arguments":[{"refId":"dart.mirrors/MirrorSystem","name":"MirrorSystem"}],"name":"Future"},"comment":"\nCreates a [MirrorSystem] for the isolate which is listening on\nthe [SendPort].\n","name":"mirrorSystemOf","id":"mirrorSystemOf1()","children":[{"ref":{"refId":"dart.isolate/SendPort","name":"SendPort"},"name":"port","id":"port","kind":"param"}],"line":"118","kind":"method"},{"returnType":{"refId":"dart.mirrors/MirrorSystem","name":"MirrorSystem"},"comment":"\nReturns a [MirrorSystem] for the current isolate.\n","name":"currentMirrorSystem","id":"currentMirrorSystem0()","line":"112","kind":"method"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nEXPERIMENTAL API: Description of how \"dart:mirrors\" is used.\n\nWhen used as metadata on an import of \"dart:mirrors\" in library *L*, this\nclass describes how \"dart:mirrors\" is used by library *L* unless overridden.\nSee [override].\n\nThe following text is non-normative:\n\nIn some scenarios, for example, when minifying Dart code, or when generating\nJavaScript code from a Dart program, the size and performance of the output\ncan suffer from use of reflection.  In those cases, telling the compiler\nwhat is used, can have a significant impact.\n\nExample usage:\n\n[:\n@MirrorsUsed(symbols: 'foo', override: '*')\nimport 'dart:mirrors';\n\nclass Foo {\n  noSuchMethod(Invocation invocation) {\n    print(Mirrors.getName(invocation.memberName));\n  }\n}\n\nmain() {\n  new Foo().foo(); // Prints \"foo\".\n  new Foo().bar(); // Might print an arbitrary (mangled) name, \"bar\".\n}\n:]\n","name":"MirrorsUsed","id":"MirrorsUsed","children":[{"isFinal":true,"comment":"\nThe list of strings passed to new [Symbol], and symbols that might be\npassed to [MirrorSystem.getName].\n\nCombined with the names of [reflectiveTarget], [metaTargets] and their\nmembers, this forms the complete list of strings passed to new [Symbol],\nand symbols that might be passed to [MirrorSystem.getName] by the library\nto which this metadata applies.\n\nThe following text is non-normative:\n\nSpecifying this option turns off the following warnings emitted by\ndart2js:\n\n* Using \"MirrorSystem.getName\" may result in larger output.\n* Using \"new #{name}\" may result in larger output.\n\nUse symbols = \"*\" to turn off the warnings mentioned above.\n\nFor example, if using [noSuchMethod] to interact with a database, extract\nall the possible column names and include them in this list.  Similarly,\nif using [noSuchMethod] to interact with another language (JavaScript, for\nexample) extract all the identifiers from API used and include them in\nthis list.\n","name":"symbols","id":"symbols","line":"1162","kind":"variable"},{"isFinal":true,"comment":"\nA list of reflective targets.\n\nCombined with [metaTargets], this provides the complete list of reflective\ntargets used by the library to which this metadata applies.\n\nThe following text is non-normative:\n\nFor now, there is no formal description of what a reflective target is.\nInformally, it is a list of things that are expected to have fully\nfunctional mirrors.\n","name":"targets","id":"targets","line":"1176","kind":"variable"},{"isFinal":true,"comment":"\nA list of classes that when used as metadata indicates a reflective\ntarget.\n\nSee [targets].\n","name":"metaTargets","id":"metaTargets","line":"1184","kind":"variable"},{"isFinal":true,"comment":"\nA list of library names or \"*\".\n\nWhen used as metadata on an import of \"dart:mirrors\", this metadata does\nnot apply to the library in which the annotation is used, but instead\napplies to the other libraries (all libraries if \"*\" is used).\n","name":"override","id":"override","line":"1193","kind":"variable"},{"name":"MirrorsUsed","id":"MirrorsUsed4()","children":[{"initializedField":{"refId":"dart.mirrors/MirrorsUsed/symbols","name":"symbols"},"isNamed":true,"isOptional":true,"name":"symbols","id":"symbols","line":"1196","kind":"param"},{"initializedField":{"refId":"dart.mirrors/MirrorsUsed/targets","name":"targets"},"isNamed":true,"isOptional":true,"name":"targets","id":"targets","line":"1196","kind":"param"},{"initializedField":{"refId":"dart.mirrors/MirrorsUsed/metaTargets","name":"metaTargets"},"isNamed":true,"isOptional":true,"name":"metaTargets","id":"metaTargets","line":"1196","kind":"param"},{"initializedField":{"refId":"dart.mirrors/MirrorsUsed/override","name":"override"},"isNamed":true,"isOptional":true,"name":"override","id":"override","line":"1196","kind":"param"}],"line":"1195","kind":"constructor"}],"line":"1131","kind":"class"},{"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nClass used for encoding comments as metadata annotations.\n","name":"Comment","id":"Comment","children":[{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"comment":"\nThe comment text as written in the source text.\n","name":"text","id":"text","line":"1077","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"comment":"\nThe comment text without the start, end, and padding text.\n\nFor example, if [text] is [: /** Comment text. */ :] then the [trimmedText]\nis [: Comment text. :].\n","name":"trimmedText","id":"trimmedText","line":"1085","kind":"variable"},{"ref":{"refId":"dart.core/bool","name":"bool"},"isFinal":true,"comment":"\nIs [:true:] if this comment is a documentation comment.\n\nThat is, that the comment is either enclosed in [: /** ... */ :] or starts\nwith [: /// :].\n","name":"isDocComment","id":"isDocComment","line":"1093","kind":"variable"},{"name":"Comment","id":"Comment3()","children":[{"initializedField":{"refId":"dart.mirrors/Comment/text","name":"text"},"ref":{"refId":"dart.core/String","name":"String"},"name":"text","id":"text","kind":"param"},{"initializedField":{"refId":"dart.mirrors/Comment/trimmedText","name":"trimmedText"},"ref":{"refId":"dart.core/String","name":"String"},"name":"trimmedText","id":"trimmedText","kind":"param"},{"initializedField":{"refId":"dart.mirrors/Comment/isDocComment","name":"isDocComment"},"ref":{"refId":"dart.core/bool","name":"bool"},"name":"isDocComment","id":"isDocComment","kind":"param"}],"line":"1095","kind":"constructor"}],"line":"1073","kind":"class"},{"interfaces":[{"refId":"dart.core/Exception","name":"Exception"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"isThrowable":true,"comment":"\nA [MirrorException] is used to indicate errors within the mirrors\nframework.\n","name":"MirrorException","id":"MirrorException","children":[{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"1066","kind":"method"},{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"name":"_message","isPrivate":true,"id":"_message","line":"1067","kind":"variable"},{"name":"MirrorException","id":"MirrorException1()","children":[{"initializedField":{"refId":"dart.mirrors/MirrorException/_message","name":"_message"},"ref":{"refId":"dart.core/String","name":"String"},"name":"_message","isPrivate":true,"id":"_message","kind":"param"}],"line":"1065","kind":"constructor"}],"line":"1064","kind":"class"},{"superclass":{"refId":"dart.mirrors/MirroredError","name":"MirroredError"},"isThrowable":true,"comment":"\nWhen a compile-time error occurs during the mirrored execution\nof code, a [MirroredCompilationError] is thrown.\n\nThis exception includes the compile-time error message that would\nhave been displayed to the user, if the function had not been\ninvoked via mirror.\n","name":"MirroredCompilationError","id":"MirroredCompilationError","children":[{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"1055","kind":"method"},{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"name":"message","id":"message","line":"1053","kind":"variable"},{"name":"MirroredCompilationError","id":"MirroredCompilationError1()","children":[{"initializedField":{"refId":"dart.mirrors/MirroredCompilationError/message","name":"message"},"ref":{"refId":"dart.core/String","name":"String"},"name":"message","id":"message","kind":"param"}],"line":"1051","kind":"constructor"}],"line":"1050","kind":"class"},{"superclass":{"refId":"dart.mirrors/MirroredError","name":"MirroredError"},"isThrowable":true,"comment":"\nWhen an uncaught exception occurs during the mirrored execution\nof code, a [MirroredUncaughtExceptionError] is thrown.\n\nThis exception contains a mirror on the original exception object.\nIt also contains an object which can be used to recover the\nstacktrace.\n","name":"MirroredUncaughtExceptionError","id":"MirroredUncaughtExceptionError","children":[{"returnType":{"refId":"dart.core/String","name":"String"},"name":"toString","id":"toString0()","line":"1036","kind":"method"},{"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"isFinal":true,"comment":"A mirror on the exception object. ","name":"exception_mirror","id":"exception_mirror","line":"1028","kind":"variable"},{"ref":{"refId":"dart.core/String","name":"String"},"isFinal":true,"comment":"The result of toString() for the exception object. ","name":"exception_string","id":"exception_string","line":"1031","kind":"variable"},{"ref":{"refId":"dart.core/Object","name":"Object"},"isFinal":true,"comment":"A stacktrace object for the uncaught exception. ","name":"stacktrace","id":"stacktrace","line":"1034","kind":"variable"},{"name":"MirroredUncaughtExceptionError","id":"MirroredUncaughtExceptionError3()","children":[{"initializedField":{"refId":"dart.mirrors/MirroredUncaughtExceptionError/exception_mirror","name":"exception_mirror"},"ref":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"name":"exception_mirror","id":"exception_mirror","kind":"param"},{"initializedField":{"refId":"dart.mirrors/MirroredUncaughtExceptionError/exception_string","name":"exception_string"},"ref":{"refId":"dart.core/String","name":"String"},"name":"exception_string","id":"exception_string","line":"1024","kind":"param"},{"initializedField":{"refId":"dart.mirrors/MirroredUncaughtExceptionError/stacktrace","name":"stacktrace"},"ref":{"refId":"dart.core/Object","name":"Object"},"name":"stacktrace","id":"stacktrace","line":"1025","kind":"param"}],"line":"1023","kind":"constructor"}],"line":"1022","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.core/Exception","name":"Exception"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"isThrowable":true,"comment":"\nWhen an error occurs during the mirrored execution of code, a\n[MirroredError] is thrown.\n\nIn general, there are three main classes of failure that can happen\nduring mirrored execution of code in some isolate:\n\n- An exception is thrown but not caught.  This is caught by the\n  mirrors framework and a [MirroredUncaughtExceptionError] is\n  created and thrown.\n\n- A compile-time error occurs, such as a syntax error.  This is\n  suppressed by the mirrors framework and a\n  [MirroredCompilationError] is created and thrown.\n\n- A truly fatal error occurs, causing the isolate to be exited.  If\n  the reflector and reflectee share the same isolate, then they\n  will both suffer.  If the reflector and reflectee are in distinct\n  isolates, then we hope to provide some information about the\n  isolate death, but this has yet to be implemented.\n\nTODO(turnidge): Specify the behavior for remote fatal errors.\n","name":"MirroredError","id":"MirroredError","line":"1011","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [SourceLocation] describes the span of an entity in Dart source code.\n","name":"SourceLocation","id":"SourceLocation","line":"985","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/VariableMirror","name":"VariableMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [ParameterMirror] reflects a Dart formal parameter declaration.\n","name":"ParameterMirror","id":"ParameterMirror","children":[{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nA mirror on the type of this parameter.\n","name":"type","id":"type","line":"958","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs this parameter optional?\n","name":"isOptional","id":"isOptional","line":"963","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs this parameter named?\n","name":"isNamed","id":"isNamed","line":"968","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nDoes this parameter have a default value?\n","name":"hasDefaultValue","id":"hasDefaultValue","line":"973","kind":"property"},{"ref":{"refId":"dart.core/String","name":"String"},"comment":"\nA mirror on the default value for this parameter, if it exists.\n","name":"defaultValue","id":"defaultValue","line":"979","kind":"property"}],"line":"954","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/DeclarationMirror","name":"DeclarationMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [VariableMirror] reflects a Dart language variable declaration.\n","name":"VariableMirror","id":"VariableMirror","children":[{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nA mirror on the type of the reflectee.\n","name":"type","id":"type","line":"935","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a static variable?\n\nFor the purposes of the mirror library, top-level variables are\nimplicitly declared static.\n","name":"isStatic","id":"isStatic","line":"943","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a final variable?\n","name":"isFinal","id":"isFinal","line":"948","kind":"property"}],"line":"931","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/DeclarationMirror","name":"DeclarationMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [MethodMirror] reflects a Dart language function, method,\nconstructor, getter, or setter.\n","name":"MethodMirror","id":"MethodMirror","children":[{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nA mirror on the return type for the reflectee.\n","name":"returnType","id":"returnType","line":"847","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.mirrors/ParameterMirror","name":"ParameterMirror"}],"name":"List"},"comment":"\nA list of mirrors on the parameters for the reflectee.\n","name":"parameters","id":"parameters","line":"852","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee static?\n\nFor the purposes of the mirrors library, a top-level function is\nconsidered static.\n","name":"isStatic","id":"isStatic","line":"860","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee abstract?\n","name":"isAbstract","id":"isAbstract","line":"865","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a regular function or method?\n\nA function or method is regular if it is not a getter, setter, or\nconstructor.  Note that operators, by this definition, are\nregular methods.\n","name":"isRegularMethod","id":"isRegularMethod","line":"874","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee an operator?\n","name":"isOperator","id":"isOperator","line":"879","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a getter?\n","name":"isGetter","id":"isGetter","line":"884","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a setter?\n","name":"isSetter","id":"isSetter","line":"889","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a constructor?\n","name":"isConstructor","id":"isConstructor","line":"894","kind":"property"},{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"comment":"\nThe constructor name for named constructors and factory methods.\n\nFor unnamed constructors, this is the empty string.  For\nnon-constructors, this is the empty string.\n\nFor example, [:'bar':] is the constructor name for constructor\n[:Foo.bar:] of type [:Foo:].\n","name":"constructorName","id":"constructorName","line":"905","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a const constructor?\n","name":"isConstConstructor","id":"isConstConstructor","line":"910","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a generative constructor?\n","name":"isGenerativeConstructor","id":"isGenerativeConstructor","line":"915","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a redirecting constructor?\n","name":"isRedirectingConstructor","id":"isRedirectingConstructor","line":"920","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs the reflectee a factory constructor?\n","name":"isFactoryConstructor","id":"isFactoryConstructor","line":"925","kind":"property"}],"line":"843","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [TypedefMirror] represents a typedef in a Dart language program.\n","name":"TypedefMirror","id":"TypedefMirror","children":[{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nThe defining type for this typedef.\n\nFor instance [:void f(int):] is the value for [:typedef void f(int):].\n","name":"value","id":"value","line":"836","kind":"property"}],"line":"830","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nA [TypeVariableMirror] represents a type parameter of a generic\ntype.\n","name":"TypeVariableMirror","id":"TypeVariableMirror","children":[{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nA mirror on the type that is the upper bound of this type variable.\n","name":"upperBound","id":"upperBound","line":"824","kind":"property"}],"line":"820","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [FunctionTypeMirror] represents the type of a function in the\nDart language.\n","name":"FunctionTypeMirror","id":"FunctionTypeMirror","children":[{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nThe return type of the reflectee.\n","name":"returnType","id":"returnType","line":"801","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.mirrors/ParameterMirror","name":"ParameterMirror"}],"name":"List"},"comment":"\nA list of the parameter types of the reflectee.\n","name":"parameters","id":"parameters","line":"806","kind":"property"},{"ref":{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"},"comment":"\nA mirror on the [:call:] method for the reflectee.\n\nTODO(turnidge): What is this and what is it for?\n","name":"callMethod","id":"callMethod","line":"813","kind":"property"}],"line":"797","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/ObjectMirror","name":"ObjectMirror"},{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [ClassMirror] reflects a Dart language class.\n","name":"ClassMirror","id":"ClassMirror","children":[{"returnType":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"comment":"\nInvokes the named constructor and returns a mirror on the result.\n\nLet *c* be the class reflected by this mirror\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nIf [constructorName] was created from the empty string\nThen this method will execute the instance creation expression\n*new c(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *c*. Otherwise, let\n*f* be the simple name of the constructor denoted by [constructorName]\nThen this method will execute the instance creation expression\n *new c.f(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *c*.\nIn either case:\nIf the expression evaluates to a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf evaluating the expression throws an exception *e* (that it does not\ncatch)\nthe the result is a [MirrorError] wrapping *e*.\n","name":"newInstance","id":"newInstance3()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"constructorName","id":"constructorName","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"positionalArguments","id":"positionalArguments","line":"734","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"}],"name":"Map"},"isOptional":true,"name":"namedArguments","id":"namedArguments","line":"735","kind":"param"}],"line":"733","kind":"method"},{"returnType":{"refId":"dart.async/Future","arguments":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"name":"Future"},"comment":"\nInvokes the named function and returns a mirror on the result.\nThe arguments must be instances of [InstanceMirror], or of\na type that is serializable across isolates (currently [num],\n[String], or [bool]).\n\nLet *c* be the class reflected by this mirror,\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nFor each *ai*, if *ai* is an instance of [InstanceMirror], let *pi*\nbe the object reflected by *ai*; otherwise let *pi = ai,  i in 1 ...n*.\nLikewise, for each *vj*, if *vj* is an instance of [InstanceMirror], let\n*qj*\nbe the object reflected by *vj*; otherwise let *qj = vj,  j in 1 ...m*.\nIf any of the *pi, qj* is not an instance of [InstanceMirror] and\nis not serializable across isolates, an exception is thrown.\nIf [constructorName] was created from the empty string\nThen this method will execute the instance creation expression\n*new c(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *c*. Otherwise, let\n*f* be the simple name of the constructor denoted by [constructorName]\nThen this method will execute the instance creation expression\n *new c.f(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *c*.\nIn either case:\nThe method returns a future *k*.\nIf the invocation returns a result *r*, *k* will be completed\nwith the result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthen *k* is completed with a [MirrorError] wrapping *e*.\n","name":"newInstanceAsync","id":"newInstanceAsync3()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"constructorName","id":"constructorName","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"positionalArguments","id":"positionalArguments","line":"773","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"}],"name":"Map"},"isOptional":true,"name":"namedArguments","id":"namedArguments","line":"774","kind":"param"}],"line":"772","kind":"method"},{"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"comment":"\nA mirror on the superclass on the reflectee.\n\nIf this type is [:Object:] or a typedef, the superClass will be\nnull.\n","name":"superclass","id":"superclass","line":"620","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"}],"name":"List"},"comment":"\nA list of mirrors on the superinterfaces of the reflectee.\n","name":"superinterfaces","id":"superinterfaces","line":"625","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/Mirror","name":"Mirror"}],"name":"Map"},"comment":"\nAn immutable map from from names to mirrors for all members of\nthis type.\n\nThe members of a type are its methods, fields, getters, and\nsetters.  Note that constructors and type variables are not\nconsidered to be members of a type.\n\nThis does not include inherited members.\n","name":"members","id":"members","line":"637","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all method,\ndeclarations for this type.  This does not include getters and\nsetters.\n","name":"methods","id":"methods","line":"644","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all getter\ndeclarations for this type.\n","name":"getters","id":"getters","line":"650","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all setter\ndeclarations for this type.\n","name":"setters","id":"setters","line":"656","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/VariableMirror","name":"VariableMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all variable\ndeclarations for this type.\n","name":"variables","id":"variables","line":"662","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all constructor\ndeclarations for this type.\n","name":"constructors","id":"constructors","line":"668","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/TypeVariableMirror","name":"TypeVariableMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all type variables for\nthis type.\n\nThis map preserves the order of declaration of the type variables.\n","name":"typeVariables","id":"typeVariables","line":"676","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all type arguments for\nthis type.\n\nThis map preserves the order of declaration of the type variables.\n","name":"typeArguments","id":"typeArguments","line":"684","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs this the original declaration of this type?\n\nFor most classes, they are their own original declaration.  For\ngeneric classes, however, there is a distinction between the\noriginal class declaration, which has unbound type variables, and\nthe instantiations of generic classes, which have bound type\nvariables.\n","name":"isOriginalDeclaration","id":"isOriginalDeclaration","line":"695","kind":"property"},{"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"comment":"\nA mirror on the original declaration of this type.\n\nFor most classes, they are their own original declaration.  For\ngeneric classes, however, there is a distinction between the\noriginal class declaration, which has unbound type variables, and\nthe instantiations of generic classes, which have bound type\nvariables.\n","name":"originalDeclaration","id":"originalDeclaration","line":"706","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nDoes this mirror represent a class?\n\nTODO(turnidge): This functions goes away after the\nclass/interface changes.\n","name":"isClass","id":"isClass","line":"782","kind":"property"},{"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"comment":"\nA mirror on the default factory class or null if there is none.\n\nTODO(turnidge): This functions goes away after the\nclass/interface changes.\n","name":"defaultFactory","id":"defaultFactory","line":"790","kind":"property"}],"line":"613","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/DeclarationMirror","name":"DeclarationMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [TypeMirror] reflects a Dart language class, typedef,\nor type variable.\n","name":"TypeMirror","id":"TypeMirror","line":"607","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/ObjectMirror","name":"ObjectMirror"},{"refId":"dart.mirrors/DeclarationMirror","name":"DeclarationMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [LibraryMirror] reflects a Dart language library, providing\naccess to the variables, functions, and classes of the\nlibrary.\n","name":"LibraryMirror","id":"LibraryMirror","children":[{"ref":{"refId":"dart.core/Uri","name":"Uri"},"comment":"\nThe absolute uri of the library.\n","name":"uri","id":"uri","line":"561","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/Mirror","name":"Mirror"}],"name":"Map"},"comment":"\nAn immutable map from from names to mirrors for all members in\nthis library.\n\nThe members of a library are its top-level classes,\nfunctions, variables, getters, and setters.\n","name":"members","id":"members","line":"570","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all class\ndeclarations in this library.\n","name":"classes","id":"classes","line":"576","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all function, getter,\nand setter declarations in this library.\n","name":"functions","id":"functions","line":"582","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all getter\ndeclarations in this library.\n","name":"getters","id":"getters","line":"588","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all setter\ndeclarations in this library.\n","name":"setters","id":"setters","line":"594","kind":"property"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"},{"refId":"dart.mirrors/VariableMirror","name":"VariableMirror"}],"name":"Map"},"comment":"\nAn immutable map from names to mirrors for all variable\ndeclarations in this library.\n","name":"variables","id":"variables","line":"600","kind":"property"}],"line":"557","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [ClosureMirror] reflects a closure.\n\nA [ClosureMirror] provides access to its captured variables and\nprovides the ability to execute its reflectee.\n","name":"ClosureMirror","id":"ClosureMirror","children":[{"returnType":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"comment":"\nExecutes the closure and returns a mirror on the result.\nLet *f* be the closure reflected by this mirror,\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nThen this method will perform the method invocation\n *f(a1, ..., an, k1: v1, ..., km: vm)*\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthe the result is a [MirrorError] wrapping *e*.\n","name":"apply","id":"apply2()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"positionalArguments","id":"positionalArguments","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"}],"name":"Map"},"isOptional":true,"name":"namedArguments","id":"namedArguments","line":"501","kind":"param"}],"line":"500","kind":"method"},{"returnType":{"refId":"dart.async/Future","arguments":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"name":"Future"},"comment":"\nExecutes the closure and returns a mirror on the result.\n\nLet *f* be the closure reflected by this mirror,\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nFor each *ai*, if *ai* is an instance of [InstanceMirror], let *pi*\nbe the object reflected by *ai*; otherwise let *pi = ai,  i in 1 ...n*.\nLikewise, for each *vj*, if *vj* is an instance of [InstanceMirror], let\n*qj*\nbe the object reflected by *vj*; otherwise let *qj = vj,  j in 1 ...m*.\nIf any of the *pi, qj* is not an instance of [InstanceMirror] and\nis not serializable across isolates, an exception is thrown.\nThen this method will perform the function invocation\n *f(p1, ..., pn, k1: q1, ..., km: qm)*\nThe method returns a future *k*.\nIf the invocation returns a result *r*, *k* will be completed\nwith the result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthen *k* is completed with a [MirrorError] wrapping *e*.\n\nThe arguments must be instances of [InstanceMirror], or of\na type that is serializable across isolates (currently [num],\n[String], or [bool]).\n","name":"applyAsync","id":"applyAsync2()","children":[{"ref":{"refId":"dart.core/List","name":"List"},"name":"positionalArguments","id":"positionalArguments","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"}],"name":"Map"},"isOptional":true,"name":"namedArguments","id":"namedArguments","line":"531","kind":"param"}],"line":"530","kind":"method"},{"returnType":{"refId":"dart.async/Future","arguments":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"name":"Future"},"comment":"\nLooks up the value of a name in the scope of the closure. The\nresult is a mirror on that value.\n\nLet *s* be the contents of the string used to construct the symbol [name].\n\nIf the expression *s* occurs within the source code of the reflectee,\nand that any such occurrence refers to a declaration outside the reflectee,\nthen let *v* be the result of evaluating the expression *s* at such\nan occurrence.\nIf *s = this*, and the reflectee was defined within the instance scope of\nan object *o*, then let *v* be *o*.\n\nThe returned value is the result of invoking the method [reflect] on\n*v*.\n","name":"findInContext","id":"findInContext1()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"name","id":"name","kind":"param"}],"line":"549","kind":"method"},{"ref":{"refId":"dart.mirrors/MethodMirror","name":"MethodMirror"},"comment":"\nA mirror on the function associated with this closure.\n","name":"function","id":"function","line":"477","kind":"property"},{"ref":{"refId":"dart.core/String","name":"String"},"comment":"\nThe source code for this closure, if available.  Otherwise null.\n\nTODO(turnidge): Would this just be available in function?\n","name":"source","id":"source","line":"484","kind":"property"}],"line":"473","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/ObjectMirror","name":"ObjectMirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn [InstanceMirror] reflects an instance of a Dart language object.\n","name":"InstanceMirror","id":"InstanceMirror","children":[{"comment":"\nPerform [invocation] on [reflectee].\nEquivalent to\n\nthis.invoke(invocation.memberName,\n            invocation.positionalArguments,\n            invocation.namedArguments);\n","name":"delegate","id":"delegate1()","children":[{"ref":{"refId":"dart.core/Invocation","name":"Invocation"},"name":"invocation","id":"invocation","kind":"param"}],"line":"464","kind":"method"},{"ref":{"refId":"dart.mirrors/ClassMirror","name":"ClassMirror"},"comment":"\nA mirror on the type of the reflectee.\n\nReturns a mirror on the actual class of the reflectee.\nThe class of the reflectee may differ from\nthe object returned by invoking [runtimeType] on\nthe reflectee.\n","name":"type","id":"type","line":"430","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nDoes [reflectee] contain the instance reflected by this mirror?\nThis will always be true in the local case (reflecting instances\nin the same isolate), but only true in the remote case if this\nmirror reflects a simple value.\n\nA value is simple if one of the following holds:\n - the value is null\n - the value is of type [num]\n - the value is of type [bool]\n - the value is of type [String]\n","name":"hasReflectee","id":"hasReflectee","line":"444","kind":"property"},{"comment":"\nIf the [InstanceMirror] reflects an instance it is meaningful to\nhave a local reference to, we provide access to the actual\ninstance here.\n\nIf you access [reflectee] when [hasReflectee] is false, an\nexception is thrown.\n","name":"reflectee","id":"reflectee","line":"454","kind":"property"}],"line":"421","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/Mirror","name":"Mirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn [ObjectMirror] is a common superinterface of [InstanceMirror],\n[ClassMirror], and [LibraryMirror] that represents their shared\nfunctionality.\n\nFor the purposes of the mirrors library, these types are all\nobject-like, in that they support method invocation and field\naccess.  Real Dart objects are represented by the [InstanceMirror]\ntype.\n\nSee [InstanceMirror], [ClassMirror], and [LibraryMirror].\n","name":"ObjectMirror","id":"ObjectMirror","children":[{"returnType":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"comment":"\nInvokes the named function and returns a mirror on the result.\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the member denoted by [memberName],\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nThen this method will perform the method invocation\n *o.f(a1, ..., an, k1: v1, ..., km: vm)*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o* (otherwise).\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthe the result is a [MirrorError] wrapping *e*.\n","name":"invoke","id":"invoke3()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"memberName","id":"memberName","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"positionalArguments","id":"positionalArguments","line":"286","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"}],"name":"Map"},"isOptional":true,"name":"namedArguments","id":"namedArguments","line":"287","kind":"param"}],"line":"285","kind":"method"},{"returnType":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"comment":"\nInvokes a getter and returns a mirror on the result. The getter\ncan be the implicit getter for a field or a user-defined getter\nmethod.\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the getter denoted by [fieldName],\nThen this method will perform the getter invocation\n *o.f*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o* (otherwise).\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthe the result is a [MirrorError] wrapping *e*.\n","name":"getField","id":"getField1()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"fieldName","id":"fieldName","kind":"param"}],"line":"307","kind":"method"},{"returnType":{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"},"comment":"\nInvokes a setter and returns a mirror on the result. The setter\nmay be either the implicit setter for a non-final field or a\nuser-defined setter method.\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the getter denoted by [fieldName],\nand let *a* be the object bound to [value].\nThen this method will perform the setter invocation\n*o.f = a*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o* (otherwise).\nIf the invocation returns a result *r*, this method returns\nthe result of calling [reflect]([value]).\nIf the invocation throws an exception *e* (that it does not catch)\nthe the result is a [MirrorError] wrapping *e*.\n","name":"setField","id":"setField2()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"fieldName","id":"fieldName","kind":"param"},{"ref":{"refId":"dart.core/Object","name":"Object"},"name":"value","id":"value","kind":"param"}],"line":"328","kind":"method"},{"returnType":{"refId":"dart.async/Future","arguments":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"name":"Future"},"comment":"\nInvokes the named function and returns a mirror on the result.\nThe arguments must be instances of [InstanceMirror], or of\na type that is serializable across isolates (currently [num],\n[String], or [bool]).\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the member denoted by [memberName],\nlet *a1, ..., an* be the elements of [positionalArguments]\nlet *k1, ..., km* be the identifiers denoted by the elements of\n[namedArguments.keys]\nand let *v1, ..., vm* be the elements of [namedArguments.values].\nFor each *ai*, if *ai* is an instance of [InstanceMirror], let *pi*\nbe the object reflected by *ai*; otherwise let *pi = ai,  i in 1 ...n*.\nLikewise, for each *vj*, if *vj* is an instance of [InstanceMirror], let *qj*\nbe the object reflected by *vj*; otherwise let *qj = vj,  j in 1 ...m*.\nIf any of the *pi, qj* is not an instance of [InstanceMirror] and\nis not serializable across isolates, an exception is thrown.\nThen this method will perform the method invocation\n *o.f(p1, ..., pn, k1: q1, ..., km: qm)*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o*(otherwise).\nThe method returns a future *k*.\nIf the invocation returns a result *r*, *k* will be completed\nwith the result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthen *k* is completed with a [MirrorError] wrapping *e*.\n","name":"invokeAsync","id":"invokeAsync3()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"memberName","id":"memberName","kind":"param"},{"ref":{"refId":"dart.core/List","name":"List"},"name":"positionalArguments","id":"positionalArguments","line":"364","kind":"param"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Symbol","name":"Symbol"}],"name":"Map"},"isOptional":true,"name":"namedArguments","id":"namedArguments","line":"365","kind":"param"}],"line":"363","kind":"method"},{"returnType":{"refId":"dart.async/Future","arguments":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"name":"Future"},"comment":"\nInvokes a getter and returns a mirror on the result. The getter\ncan be the implicit getter for a field or a user-defined getter\nmethod.\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the getter denoted by [fieldName],\nThen this method will perform the getter invocation\n *o.f*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o*(otherwise).\nThe method returns a future *k*.\nIf the invocation returns a result *r*, *k* will be completed\nwith the result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthen *k* is completed with a [MirrorError] wrapping *e*.\n","name":"getFieldAsync","id":"getFieldAsync1()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"fieldName","id":"fieldName","kind":"param"}],"line":"386","kind":"method"},{"returnType":{"refId":"dart.async/Future","arguments":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"name":"Future"},"comment":"\nInvokes a setter and returns a mirror on the result. The setter\nmay be either the implicit setter for a non-final field or a\nuser-defined setter method.\nThe second argument must be an instance of [InstanceMirror], or of\na type that is serializable across isolates (currently [num],\n[String], or [bool]).\n\nLet *o* be the object reflected by this mirror, let\n*f* be the simple name of the getter denoted by [fieldName],\nand let a be the object bound to [value]. If *a* is an instance of\n[InstanceMirror]  let *p* be the object\nreflected by *a*, otherwise let *p =a*.\nIf *p* is not an instance of [InstanceMirror], *p* must be\nserializable across isolates or an exception is thrown.\nThen this method will perform the setter invocation\n *o.f = a*\nin a scope that has access to the private members\nof *o* (if *o* is a class or library) or the private members of the\nclass of *o*(otherwise).\nThe method returns a future *k*.\nIf the invocation returns a result *r*, *k* will be completed\nwith the result of calling [reflect](*r*).\nIf the invocation throws an exception *e* (that it does not catch)\nthen *k* is completed with a [MirrorError} wrapping *e*.\n","name":"setFieldAsync","id":"setFieldAsync2()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"fieldName","id":"fieldName","kind":"param"},{"ref":{"refId":"dart.core/Object","name":"Object"},"name":"value","id":"value","kind":"param"}],"line":"415","kind":"method"}],"line":"260","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/Mirror","name":"Mirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [DeclarationMirror] reflects some entity declared in a Dart program.\n","name":"DeclarationMirror","id":"DeclarationMirror","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"comment":"\nThe simple name for this Dart language entity.\n\nThe simple name is in most cases the the identifier name of the\nentity, such as 'method' for a method [:void method() {...}:] or\n'mylibrary' for a [:#library('mylibrary');:] declaration.\n","name":"simpleName","id":"simpleName","line":"178","kind":"property"},{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"comment":"\nThe fully-qualified name for this Dart language entity.\n\nThis name is qualified by the name of the owner. For instance,\nthe qualified name of a method 'method' in class 'Class' in\nlibrary 'library' is 'library.Class.method'.\n\nReturns a [Symbol] constructed from a string representing the\nfully qualified name of the reflectee.\nLet *o* be the [owner] of this mirror, let *r* be the reflectee of\nthis mirror, let *p* be the fully qualified\nname of the reflectee of *o*, and let *s* be the simple name of *r*\ncomputed by [simpleName].\nThe fully qualified name of *r* is the\nconcatenation of *p*, '.', and *s*.\n","name":"qualifiedName","id":"qualifiedName","line":"196","kind":"property"},{"ref":{"refId":"dart.mirrors/DeclarationMirror","name":"DeclarationMirror"},"comment":"\nA mirror on the owner of this function.  This is the declaration\nimmediately surrounding the reflectee.\n\nFor a library, the owner is [:null:].\nFor a class, typedef or top level function or variable, the owner is\nthe enclosing library. For a method, instance variable or\na static variable, the owner is the immediately enclosing class.\nFor a parameter, local variable or local function the owner is the\nimmediately enclosing function.\n","name":"owner","id":"owner","line":"209","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs this declaration private?\n\nA declaration is private if and only if it is considered private\naccording to the Dart language specification.\nNote that for libraries, this will be [:false:].\n","name":"isPrivate","id":"isPrivate","line":"218","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nIs this declaration top-level?\n\nThis is defined to be equivalent to:\n   [:mirror.owner != null && mirror.owner is LibraryMirror:]\n","name":"isTopLevel","id":"isTopLevel","line":"226","kind":"property"},{"ref":{"refId":"dart.mirrors/SourceLocation","name":"SourceLocation"},"comment":"\nThe source location of this Dart language entity.\n","name":"location","id":"location","line":"231","kind":"property"},{"ref":{"refId":"dart.core/List","arguments":[{"refId":"dart.mirrors/InstanceMirror","name":"InstanceMirror"}],"name":"List"},"comment":"\nA list of the metadata associated with this declaration.\n\nLet *D* be the declaration this mirror reflects.\nIf *D* is decorated with annotations *A1, ..., An*\nwhere *n > 0*, then for each annotation *Ai* associated \nwith *D, 1 <= i <= n*, let *ci* be the constant object \nspecified by *Ai*. Then this method returns a list whose \nmembers are instance mirrors on *c1, ..., cn*.\nIf no annotations are associated with *D*, then \nan empty list is returned.\n","name":"metadata","id":"metadata","line":"245","kind":"property"}],"line":"170","kind":"class"},{"isAbstract":true,"interfaces":[{"refId":"dart.mirrors/Mirror","name":"Mirror"}],"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nAn [IsolateMirror] reflects an isolate.\n","name":"IsolateMirror","id":"IsolateMirror","children":[{"ref":{"refId":"dart.core/String","name":"String"},"comment":"\nA unique name used to refer to an isolate in debugging messages.\n","name":"debugName","id":"debugName","line":"154","kind":"property"},{"ref":{"refId":"dart.core/bool","name":"bool"},"comment":"\nDoes this mirror reflect the currently running isolate?\n","name":"isCurrent","id":"isCurrent","line":"159","kind":"property"},{"ref":{"refId":"dart.mirrors/LibraryMirror","name":"LibraryMirror"},"comment":"\nA mirror on the root library for this isolate.\n","name":"rootLibrary","id":"rootLibrary","line":"164","kind":"property"}],"line":"150","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [Mirror] reflects some Dart language entity.\n\nEvery [Mirror] originates from some [MirrorSystem].\n","name":"Mirror","id":"Mirror","children":[{"ref":{"refId":"dart.mirrors/MirrorSystem","name":"MirrorSystem"},"comment":"\nThe [MirrorSystem] that contains this mirror.\n","name":"mirrors","id":"mirrors","line":"144","kind":"property"}],"line":"140","kind":"class"},{"isAbstract":true,"superclass":{"refId":"dart.core/Object","name":"Object"},"comment":"\nA [MirrorSystem] is the main interface used to reflect on a set of\nassociated libraries.\n\nAt runtime each running isolate has a distinct [MirrorSystem].\n\nIt is also possible to have a [MirrorSystem] which represents a set\nof libraries which are not running -- perhaps at compile-time.  In\nthis case, all available reflective functionality would be\nsupported, but runtime functionality (such as invoking a function\nor inspecting the contents of a variable) would fail dynamically.\n","name":"MirrorSystem","id":"MirrorSystem","children":[{"returnType":{"refId":"dart.core/Iterable","arguments":[{"refId":"dart.mirrors/LibraryMirror","name":"LibraryMirror"}],"name":"Iterable"},"comment":"\nReturns an iterable of all libraries in the mirror system whose library\nname is [libraryName].\n","name":"findLibrary","id":"findLibrary1()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"libraryName","id":"libraryName","kind":"param"}],"line":"77","kind":"method"},{"returnType":{"refId":"dart.core/String","name":"String"},"isStatic":true,"comment":"\nReturns the name of [symbol].\n\nThe following text is non-normative:\n\nUsing this method may result in larger output.  If possible, use\n[MirrorsUsed] to specify which symbols must be retained in clear text.\n","name":"getName","id":"getName1()","children":[{"ref":{"refId":"dart.core/Symbol","name":"Symbol"},"name":"symbol","id":"symbol","kind":"param"}],"line":"106","kind":"method"},{"ref":{"refId":"dart.core/Map","arguments":[{"refId":"dart.core/Uri","name":"Uri"},{"refId":"dart.mirrors/LibraryMirror","name":"LibraryMirror"}],"name":"Map"},"comment":"\nAn immutable map from from library names to mirrors for all\nlibraries known to this mirror system.\n","name":"libraries","id":"libraries","line":"71","kind":"property"},{"ref":{"refId":"dart.mirrors/IsolateMirror","name":"IsolateMirror"},"comment":"\nA mirror on the isolate associated with this [MirrorSystem].\nThis may be null if this mirror system is not running.\n","name":"isolate","id":"isolate","line":"86","kind":"property"},{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nA mirror on the [:dynamic:] type.\n","name":"dynamicType","id":"dynamicType","line":"91","kind":"property"},{"ref":{"refId":"dart.mirrors/TypeMirror","name":"TypeMirror"},"comment":"\nA mirror on the [:void:] type.\n","name":"voidType","id":"voidType","line":"96","kind":"property"}],"line":"66","kind":"class"}],"line":"49","kind":"library"}