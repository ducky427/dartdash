        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>NumberFormat class / intl Library / Dart API Reference</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        <link rel="stylesheet" type="text/css"
            href="../apidoc-styles.css" />
        
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(["_setAccount", "UA-26406144-9"]);
          _gaq.push(["_trackPageview"]);

          (function() {
            var ga = document.createElement("script");
            ga.type = "text/javascript"; ga.async = true;
            ga.src = ("https:" == document.location.protocol ?
              "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(ga, s);
          })();
        </script>
        
        </head>
        <body data-library="intl" data-type="NumberFormat">
        <div class="page">
        <div class="header">
          <a href="http://dartlang.org" ref="external"><div class="logo"></div></a>
          <a href="../index.html">Dart API Reference</a>
         &rsaquo; <a href="../intl.html">intl</a> &rsaquo; <a href="../intl/NumberFormat.html">NumberFormat</a>        <form action="http://www.dartlang.org/search.html" id="search-box">
          <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
          <input type="hidden" name="ie" value="UTF-8">
          <input type="hidden" name="hl" value="en">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </form>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
<h2><div class="icon-library"></div><a href="../args.html">args</a></h2><h2><div class="icon-library"></div><a href="../crypto.html">crypto</a></h2><h2><div class="icon-library"></div><a href="../dart_async.html">dart:async</a></h2><h2><div class="icon-library"></div><a href="../dart_chrome.html">dart:chrome</a></h2><h2><div class="icon-library"></div><a href="../dart_collection.html">dart:collection</a></h2><h2><div class="icon-library"></div><a href="../dart_core.html">dart:core</a></h2><h2><div class="icon-library"></div><a href="../dart_html.html">dart:html</a></h2><h2><div class="icon-library"></div><a href="../dart_indexed_db.html">dart:indexed_db</a></h2><h2><div class="icon-library"></div><a href="../dart_io.html">dart:io</a></h2><h2><div class="icon-library"></div><a href="../dart_isolate.html">dart:isolate</a></h2><h2><div class="icon-library"></div><a href="../dart_json.html">dart:json</a></h2><h2><div class="icon-library"></div><a href="../dart_math.html">dart:math</a></h2><h2><div class="icon-library"></div><a href="../dart_mirrors.html">dart:mirrors</a></h2><h2><div class="icon-library"></div><a href="../dart_svg.html">dart:svg</a></h2><h2><div class="icon-library"></div><a href="../dart_typed_data.html">dart:typed_data</a></h2><h2><div class="icon-library"></div><a href="../dart_utf.html">dart:utf</a></h2><h2><div class="icon-library"></div><a href="../dart_web_audio.html">dart:web_audio</a></h2><h2><div class="icon-library"></div><a href="../dart_web_gl.html">dart:web_gl</a></h2><h2><div class="icon-library"></div><a href="../dart_web_sql.html">dart:web_sql</a></h2><h2><div class="icon-library"></div><a href="../fixnum.html">fixnum</a></h2><h2><div class="icon-library"></div><a href="../intl.html">intl</a></h2><ul class="icon">
<li><a href="../intl/Bidi.html"><div class="icon-class"></div>Bidi</a></li>
<li><a href="../intl/BidiFormatter.html"><div class="icon-class"></div>BidiFormatter</a></li>
<li><a href="../intl/DateFormat.html"><div class="icon-class"></div>DateFormat</a></li>
<li><a href="../intl/Intl.html"><div class="icon-class"></div>Intl</a></li>
<li><div class="icon-class"></div><strong>NumberFormat</strong></li>
<li><a href="../intl/TextDirection.html"><div class="icon-class"></div>TextDirection</a></li>
</ul>
<h2><div class="icon-library"></div><a href="../logging.html">logging</a></h2><h2><div class="icon-library"></div><a href="../matcher.html">matcher</a></h2><h2><div class="icon-library"></div><a href="../mdv_observe.html">mdv_observe</a></h2><h2><div class="icon-library"></div><a href="../meta.html">meta</a></h2><h2><div class="icon-library"></div><a href="../mock.html">mock</a></h2><h2><div class="icon-library"></div><a href="../serialization.html">serialization</a></h2><h2><div class="icon-library"></div><a href="../source_maps.html">source_maps</a></h2><h2><div class="icon-library"></div><a href="../unittest.html">unittest</a></h2></div>
<div class="content">
        <h2><strong>NumberFormat</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Provides the ability to format a number in a locale-specific way. The
format is specified as a pattern using a subset of the ICU formatting
patterns.</p><ul><li><code>0</code> A single digit</li><li><code>#</code> A single digit, omitted if the value is zero</li><li><code>.</code> Decimal separator</li><li><code>-</code> Minus sign</li><li><code>,</code> Grouping separator</li><li><code>E</code> Separates mantissa and expontent</li><li><code>+</code> - Before an exponent, indicates it should be prefixed with a plus sign.</li><li><code>%</code> - In prefix or suffix, multiply by 100 and show as percentage</li><li><code>‰ (\u2030)</code> In prefix or suffix, multiply by 1000 and show as per mille</li><li><code>¤ (\u00A4)</code> Currency sign, replaced by currency name</li><li><code>'</code> Used to quote special characters</li><li><code>;</code> Used to separate the positive and negative patterns if both are present</li></ul>
<p>For example,</p>
<pre><code>  var f = new NumberFormat("###.0#", "en_US");
  print(f.format(12.345));
  ==&gt; 12.34
</code></pre>
<p>If the locale is not specified, it will default to the current locale. If
the format is not specified it will print in a basic format with at least
one integer digit and three fraction digits.</p>
<p>There are also standard patterns available via the special constructors. e.g.</p>
<pre><code>  var symbols = new NumberFormat.percentFormat("ar");
</code></pre>
<p>There are four such constructors: decimalFormat, percentFormat,
scientificFormat and currencyFormat. However, at the moment,
scientificFormat prints only as equivalent to "#E0" and does not take
into account significant digits. currencyFormat will always use the name
of the currency rather than the symbol.</p>
<pre class="source">
class NumberFormat {
 /** Variables to determine how number printing behaves. */
 // TODO(alanknight): If these remain as variables and are set based on the
 // pattern, can we make them final?
 String _negativePrefix = '-';
 String _positivePrefix = '';
 String _negativeSuffix = '';
 String _positiveSuffix = '';
 /**
  * How many numbers in a group when using punctuation to group digits in
  * large numbers. e.g. in en_US: "1,000,000" has a grouping size of 3 digits
  * between commas.
  */
 int _groupingSize = 3;
 bool _decimalSeparatorAlwaysShown = false;
 bool _useSignForPositiveExponent = false;
 bool _useExponentialNotation = false;

 int maximumIntegerDigits = 40;
 int minimumIntegerDigits = 1;
 int maximumFractionDigits = 3;
 int minimumFractionDigits = 0;
 int minimumExponentDigits = 0;

 int _multiplier = 1;

 /**
  * Stores the pattern used to create this format. This isn't used, but
  * is helpful in debugging.
  */
 String _pattern;

 /** The locale in which we print numbers. */
 final String _locale;

 /** Caches the symbols used for our locale. */
 NumberSymbols _symbols;

 /**
  * Transient internal state in which to build up the result of the format
  * operation. We can have this be just an instance variable because Dart is
  * single-threaded and unless we do an asynchronous operation in the process
  * of formatting then there will only ever be one number being formatted
  * at a time. In languages with threads we'd need to pass this on the stack.
  */
 StringBuffer _buffer;

 /**
  * Create a number format that prints using [newPattern] as it applies in
  * [locale].
  */
 factory NumberFormat([String newPattern, String locale]) {
   return new NumberFormat._forPattern(locale, (x) =&gt; newPattern);
 }

 /** Create a number format that prints as DECIMAL_PATTERN. */
 NumberFormat.decimalPattern([String locale]) :
     this._forPattern(locale, (x) =&gt; x.DECIMAL_PATTERN);

 /** Create a number format that prints as PERCENT_PATTERN. */
 NumberFormat.percentPattern([String locale]) :
   this._forPattern(locale, (x) =&gt; x.PERCENT_PATTERN);

 /** Create a number format that prints as SCIENTIFIC_PATTERN. */
 NumberFormat.scientificPattern([String locale]) :
   this._forPattern(locale, (x) =&gt; x.SCIENTIFIC_PATTERN);

 /** Create a number format that prints as CURRENCY_PATTERN. */
 NumberFormat.currencyPattern([String locale]) :
   this._forPattern(locale, (x) =&gt; x.CURRENCY_PATTERN);

 /**
  * Create a number format that prints in a pattern we get from
  * the [getPattern] function using the locale [locale].
  */
 NumberFormat._forPattern(String locale, Function getPattern) :
     _locale = Intl.verifiedLocale(locale, localeExists) {
   _symbols = numberFormatSymbols[_locale];
   _setPattern(getPattern(_symbols));
 }

 /**
  * Return the locale code in which we operate, e.g. 'en_US' or 'pt'.
  */
 String get locale =&gt; _locale;

 /**
  * Return true if the locale exists, or if it is null. The null case
  * is interpreted to mean that we use the default locale.
  */
 static bool localeExists(localeName) {
   if (localeName == null) return false;
   return numberFormatSymbols.containsKey(localeName);
 }

 /**
  * Return the symbols which are used in our locale. Cache them to avoid
  * repeated lookup.
  */
 NumberSymbols get symbols {
   return _symbols;
 }

 /**
  * Format [number] according to our pattern and return the formatted string.
  */
 String format(num number) {
   // TODO(alanknight): Do we have to do anything for printing numbers bidi?
   // Or are they always printed left to right?
   if (number.isNaN) return symbols.NAN;
   if (number.isInfinite) return "${_signPrefix(number)}${symbols.INFINITY}";

   _newBuffer();
   _add(_signPrefix(number));
   _formatNumber(number.abs() * _multiplier);
   _add(_signSuffix(number));

   var result = _buffer.toString();
   _buffer = null;
   return result;
 }

 /**
  * Format the main part of the number in the form dictated by the pattern.
  */
 void _formatNumber(num number) {
   if (_useExponentialNotation) {
     _formatExponential(number);
   } else {
     _formatFixed(number);
   }
 }

 /** Format the number in exponential notation. */
 void _formatExponential(num number) {
   if (number == 0.0) {
     _formatFixed(number);
     _formatExponent(0);
     return;
   }

   var exponent = (log(number) / log(10)).floor();
   var mantissa = number / pow(10.0, exponent);

   var minIntDigits = minimumIntegerDigits;
   if (maximumIntegerDigits &gt; 1 &amp;&amp;
       maximumIntegerDigits &gt; minimumIntegerDigits) {
     // A repeating range is defined; adjust to it as follows.
     // If repeat == 3, we have 6,5,4=&gt;3; 3,2,1=&gt;0; 0,-1,-2=&gt;-3;
     // -3,-4,-5=&gt;-6, etc. This takes into account that the
     // exponent we have here is off by one from what we expect;
     // it is for the format 0.MMMMMx10^n.
     while ((exponent % maximumIntegerDigits) != 0) {
       mantissa *= 10;
       exponent--;
     }
     minIntDigits = 1;
   } else {
     // No repeating range is defined, use minimum integer digits.
     if (minimumIntegerDigits &lt; 1) {
       exponent++;
       mantissa /= 10;
     } else {
       exponent -= minimumIntegerDigits - 1;
       mantissa *= pow(10, minimumIntegerDigits - 1);
     }
   }
   _formatFixed(mantissa);
   _formatExponent(exponent);
 }

 /**
  * Format the exponent portion, e.g. in "1.3e-5" the "e-5".
  */
 void _formatExponent(num exponent) {
   _add(symbols.EXP_SYMBOL);
   if (exponent &lt; 0) {
     exponent = -exponent;
     _add(symbols.MINUS_SIGN);
   } else if (_useSignForPositiveExponent) {
     _add(symbols.PLUS_SIGN);
   }
   _pad(minimumExponentDigits, exponent.toString());
 }

 /** Used to test if we have exceeded Javascript integer limits. */
 final _maxInt = pow(2, 52);

 /**
  * Format the basic number portion, inluding the fractional digits.
  */
 void _formatFixed(num number) {
   // Very fussy math to get integer and fractional parts.
   var power = pow(10, maximumFractionDigits);
   var shiftedNumber = (number * power);
   // We must not roundToDouble() an int or it will lose precision. We must not
   // round() a large double or it will take its loss of precision and
   // preserve it in an int, which we will then print to the right
   // of the decimal place. Therefore, only roundToDouble if we are already
   // a double.
   if (shiftedNumber is double) {
     shiftedNumber = shiftedNumber.roundToDouble();
   }
   var intValue, fracValue;
   if (shiftedNumber.isInfinite) {
     intValue = number.toInt();
     fracValue = 0;
   } else {
     intValue = shiftedNumber.round() ~/ power;
     fracValue = (shiftedNumber - intValue * power).floor();
   }
   var fractionPresent = minimumFractionDigits &gt; 0 || fracValue &gt; 0;

   // If the int part is larger than 2^52 and we're on Javascript (so it's
   // really a float) it will lose precision, so pad out the rest of it
   // with zeros. Check for Javascript by seeing if an integer is double.
   var paddingDigits = new StringBuffer();
   if (1 is double &amp;&amp; intValue &gt; _maxInt) {
       var howManyDigitsTooBig = (log(intValue) / LN10).ceil() - 16;
       var divisor = pow(10, howManyDigitsTooBig).round();
       for (var each in new List(howManyDigitsTooBig.toInt())) {
         paddingDigits.write(symbols.ZERO_DIGIT);
       }
       intValue = (intValue / divisor).truncate();
   }
   var integerDigits = "${intValue}${paddingDigits}".codeUnits;
   var digitLength = integerDigits.length;

   if (_hasPrintableIntegerPart(intValue)) {
     _pad(minimumIntegerDigits - digitLength);
     for (var i = 0; i &lt; digitLength; i++) {
       _addDigit(integerDigits[i]);
       _group(digitLength, i);
     }
   } else if (!fractionPresent) {
     // If neither fraction nor integer part exists, just print zero.
     _addZero();
   }

   _decimalSeparator(fractionPresent);
   _formatFractionPart((fracValue + power).toString());
 }

 /**
  * Format the part after the decimal place in a fixed point number.
  */
 void _formatFractionPart(String fractionPart) {
   var fractionCodes = fractionPart.codeUnits;
   var fractionLength = fractionPart.length;
   while(fractionCodes[fractionLength - 1] == _zero &amp;&amp;
          fractionLength &gt; minimumFractionDigits + 1) {
     fractionLength--;
   }
   for (var i = 1; i &lt; fractionLength; i++) {
     _addDigit(fractionCodes[i]);
   }
 }

 /** Print the decimal separator if appropriate. */
 void _decimalSeparator(bool fractionPresent) {
   if (_decimalSeparatorAlwaysShown || fractionPresent) {
     _add(symbols.DECIMAL_SEP);
   }
 }

 /**
  * Return true if we have a main integer part which is printable, either
  * because we have digits left of the decimal point, or because there are
  * a minimum number of printable digits greater than 1.
  */
 bool _hasPrintableIntegerPart(int intValue) {
   return intValue &gt; 0 || minimumIntegerDigits &gt; 0;
 }

 /**
  * Create a new empty buffer. See comment on [_buffer] variable for why
  * we have it as an instance variable rather than passing it on the stack.
  */
 void _newBuffer() { _buffer = new StringBuffer(); }

 /** A group of methods that provide support for writing digits and other
  * required characters into [_buffer] easily.
  */
 void _add(String x) { _buffer.write(x);}
 void _addCharCode(int x) { _buffer.writeCharCode(x); }
 void _addZero() { _buffer.write(symbols.ZERO_DIGIT); }
 void _addDigit(int x) { _buffer.writeCharCode(_localeZero + x - _zero); }

 /** Print padding up to [numberOfDigits] above what's included in [basic]. */
 void _pad(int numberOfDigits, [String basic = '']) {
   for (var i = 0; i &lt; numberOfDigits - basic.length; i++) {
     _add(symbols.ZERO_DIGIT);
   }
   for (var x in basic.codeUnits) {
     _addDigit(x);
   }
 }

 /**
  * We are printing the digits of the number from left to right. We may need
  * to print a thousands separator or other grouping character as appropriate
  * to the locale. So we find how many places we are from the end of the number
  * by subtracting our current [position] from the [totalLength] and print
  * the separator character every [_groupingSize] digits.
  */
 void _group(int totalLength, int position) {
   var distanceFromEnd = totalLength - position;
   if (distanceFromEnd &lt;= 1 || _groupingSize &lt;= 0) return;
   if (distanceFromEnd % _groupingSize == 1) {
     _add(symbols.GROUP_SEP);
   }
 }

 /** Returns the code point for the character '0'. */
 final _zero = '0'.codeUnits.first;

 /** Returns the code point for the locale's zero digit. */
 // Note that there is a slight risk of a locale's zero digit not fitting
 // into a single code unit, but it seems very unlikely, and if it did,
 // there's a pretty good chance that our assumptions about being able to do
 // arithmetic on it would also be invalid.
 get _localeZero =&gt; symbols.ZERO_DIGIT.codeUnits.first;

 /**
  * Returns the prefix for [x] based on whether it's positive or negative.
  * In en_US this would be '' and '-' respectively.
  */
 String _signPrefix(num x) {
   return x.isNegative ? _negativePrefix : _positivePrefix;
 }

 /**
  * Returns the suffix for [x] based on wether it's positive or negative.
  * In en_US there are no suffixes for positive or negative.
  */
 String _signSuffix(num x) {
   return x.isNegative ? _negativeSuffix : _positiveSuffix;
 }

 void _setPattern(String newPattern) {
   if (newPattern == null) return;
   // Make spaces non-breaking
   _pattern = newPattern.replaceAll(' ', '\u00a0');
   var parser = new _NumberFormatParser(this, newPattern);
   parser.parse();
 }

 String toString() =&gt; "NumberFormat($_locale, $_pattern)";
}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="localeExists">
<button class="show-code">Code</button>
<a href="../dart_core/bool.html">bool</a> <strong>localeExists</strong>(localeName) <a class="anchor-link" href="#localeExists"
              title="Permalink to NumberFormat.localeExists">#</a></h4>
<div class="doc">
<p>Return true if the locale exists, or if it is null. The null case
is interpreted to mean that we use the default locale.</p>
<pre class="source">
static bool localeExists(localeName) {
 if (localeName == null) return false;
 return numberFormatSymbols.containsKey(localeName);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="NumberFormat">
<button class="show-code">Code</button>
factory <strong>NumberFormat</strong>([<a href="../dart_core/String.html">String</a> newPattern, <a href="../dart_core/String.html">String</a> locale]) <a class="anchor-link" href="#NumberFormat"
              title="Permalink to NumberFormat.NumberFormat">#</a></h4>
<div class="doc">
<p>Create a number format that prints using 
<span class="param">newPattern</span> as it applies in

<span class="param">locale</span>.</p>
<pre class="source">
factory NumberFormat([String newPattern, String locale]) {
 return new NumberFormat._forPattern(locale, (x) =&gt; newPattern);
}
</pre>
</div>
</div>
<div class="method"><h4 id="NumberFormat.currencyPattern">
<button class="show-code">Code</button>
new <strong>NumberFormat.currencyPattern</strong>([<a href="../dart_core/String.html">String</a> locale]) <a class="anchor-link" href="#NumberFormat.currencyPattern"
              title="Permalink to NumberFormat.NumberFormat.currencyPattern">#</a></h4>
<div class="doc">
<p>Create a number format that prints as CURRENCY_PATTERN. </p>
<pre class="source">
NumberFormat.currencyPattern([String locale]) :
 this._forPattern(locale, (x) =&gt; x.CURRENCY_PATTERN);
</pre>
</div>
</div>
<div class="method"><h4 id="NumberFormat.decimalPattern">
<button class="show-code">Code</button>
new <strong>NumberFormat.decimalPattern</strong>([<a href="../dart_core/String.html">String</a> locale]) <a class="anchor-link" href="#NumberFormat.decimalPattern"
              title="Permalink to NumberFormat.NumberFormat.decimalPattern">#</a></h4>
<div class="doc">
<p>Create a number format that prints as DECIMAL_PATTERN. </p>
<pre class="source">
NumberFormat.decimalPattern([String locale]) :
   this._forPattern(locale, (x) =&gt; x.DECIMAL_PATTERN);
</pre>
</div>
</div>
<div class="method"><h4 id="NumberFormat.percentPattern">
<button class="show-code">Code</button>
new <strong>NumberFormat.percentPattern</strong>([<a href="../dart_core/String.html">String</a> locale]) <a class="anchor-link" href="#NumberFormat.percentPattern"
              title="Permalink to NumberFormat.NumberFormat.percentPattern">#</a></h4>
<div class="doc">
<p>Create a number format that prints as PERCENT_PATTERN. </p>
<pre class="source">
NumberFormat.percentPattern([String locale]) :
 this._forPattern(locale, (x) =&gt; x.PERCENT_PATTERN);
</pre>
</div>
</div>
<div class="method"><h4 id="NumberFormat.scientificPattern">
<button class="show-code">Code</button>
new <strong>NumberFormat.scientificPattern</strong>([<a href="../dart_core/String.html">String</a> locale]) <a class="anchor-link" href="#NumberFormat.scientificPattern"
              title="Permalink to NumberFormat.NumberFormat.scientificPattern">#</a></h4>
<div class="doc">
<p>Create a number format that prints as SCIENTIFIC_PATTERN. </p>
<pre class="source">
NumberFormat.scientificPattern([String locale]) :
 this._forPattern(locale, (x) =&gt; x.SCIENTIFIC_PATTERN);
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="locale">
<button class="show-code">Code</button>
final <a href="../dart_core/String.html">String</a>         <strong>locale</strong> <a class="anchor-link"
            href="#locale"
            title="Permalink to NumberFormat.locale">#</a>
        </h4>
        <div class="doc">
<p>Return the locale code in which we operate, e.g. 'en_US' or 'pt'.</p>
<pre class="source">
String get locale =&gt; _locale;
</pre>
</div>
</div>
<div class="field"><h4 id="maximumFractionDigits">
<button class="show-code">Code</button>
<a href="../dart_core/int.html">int</a>         <strong>maximumFractionDigits</strong> <a class="anchor-link"
            href="#maximumFractionDigits"
            title="Permalink to NumberFormat.maximumFractionDigits">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int maximumFractionDigits = 3
</pre>
</div>
</div>
<div class="field"><h4 id="maximumIntegerDigits">
<button class="show-code">Code</button>
<a href="../dart_core/int.html">int</a>         <strong>maximumIntegerDigits</strong> <a class="anchor-link"
            href="#maximumIntegerDigits"
            title="Permalink to NumberFormat.maximumIntegerDigits">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int maximumIntegerDigits = 40
</pre>
</div>
</div>
<div class="field"><h4 id="minimumExponentDigits">
<button class="show-code">Code</button>
<a href="../dart_core/int.html">int</a>         <strong>minimumExponentDigits</strong> <a class="anchor-link"
            href="#minimumExponentDigits"
            title="Permalink to NumberFormat.minimumExponentDigits">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int minimumExponentDigits = 0
</pre>
</div>
</div>
<div class="field"><h4 id="minimumFractionDigits">
<button class="show-code">Code</button>
<a href="../dart_core/int.html">int</a>         <strong>minimumFractionDigits</strong> <a class="anchor-link"
            href="#minimumFractionDigits"
            title="Permalink to NumberFormat.minimumFractionDigits">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int minimumFractionDigits = 0
</pre>
</div>
</div>
<div class="field"><h4 id="minimumIntegerDigits">
<button class="show-code">Code</button>
<a href="../dart_core/int.html">int</a>         <strong>minimumIntegerDigits</strong> <a class="anchor-link"
            href="#minimumIntegerDigits"
            title="Permalink to NumberFormat.minimumIntegerDigits">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int minimumIntegerDigits = 1
</pre>
</div>
</div>
<div class="field"><h4 id="symbols">
<button class="show-code">Code</button>
final NumberSymbols         <strong>symbols</strong> <a class="anchor-link"
            href="#symbols"
            title="Permalink to NumberFormat.symbols">#</a>
        </h4>
        <div class="doc">
<p>Return the symbols which are used in our locale. Cache them to avoid
repeated lookup.</p>
<pre class="source">
NumberSymbols get symbols {
 return _symbols;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="format">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>format</strong>(<a href="../dart_core/num.html">num</a> number) <a class="anchor-link" href="#format"
              title="Permalink to NumberFormat.format">#</a></h4>
<div class="doc">
<p>Format 
<span class="param">number</span> according to our pattern and return the formatted string.</p>
<pre class="source">
String format(num number) {
 // TODO(alanknight): Do we have to do anything for printing numbers bidi?
 // Or are they always printed left to right?
 if (number.isNaN) return symbols.NAN;
 if (number.isInfinite) return "${_signPrefix(number)}${symbols.INFINITY}";

 _newBuffer();
 _add(_signPrefix(number));
 _formatNumber(number.abs() * _multiplier);
 _add(_signSuffix(number));

 var result = _buffer.toString();
 _buffer = null;
 return result;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
<a href="../dart_core/String.html">String</a> <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to NumberFormat.toString">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns a string representation of this object.</p>
<div class="docs-inherited-from">docs inherited from <a href="../dart_core/Object.html">Object</a> </div></div>
<pre class="source">
String toString() =&gt; "NumberFormat($_locale, $_pattern)";
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-06-21 06:35:30.853</div>
<div>        <p>Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>, the content of this
        page is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution
        3.0 License</a>, and code samples are licensed under the
        <a href="http://code.google.com/google_bsd_license.html">BSD License</a>.</p>
        <p><a href="http://www.dartlang.org/tos.html">Terms of Service</a> |
        <a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a></p>
        </div>
        </div>
        <script async src="../client-static.js"></script>
        </body></html>
        
